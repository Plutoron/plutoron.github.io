(window.webpackJsonp=window.webpackJsonp||[]).push([[2],Array(100).concat([function(e,n,t){"use strict";e.exports=function(e,n){return n||(n={}),"string"!=typeof(e=e&&e.__esModule?e.default:e)?e:(n.hash&&(e+=n.hash),n.maybeNeedQuotes&&/[\t\n\f\r "'=<>`]/.test(e)?'"'.concat(e,'"'):e)}},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(e,n,t){"use strict";t.r(n);var r=t(0),o=t(1);t(130);n.default=function(){console.log(Object(o.g)());var e=Object(o.g)().fileName;return r.createElement("article",{className:"markdown-body mt20 mb20",dangerouslySetInnerHTML:{__html:t(192)("./".concat(e))}})}},function(e,n,t){var r={"./19.10.12-useEffect 的坑.md":193,"./19.10.12-webpack4新手向.md":194,"./19.10.12-新的开始.md":195,"./19.10.15-webpack4+react+babel 踩坑.md":196,"./19.10.18-搭建自己的Github Page.md":197,"./19.10.24-webpack打包优化.md":198,"./19.10.26-瞎搞webhook.md":199,"./19.10.30-记一道面试题.md":202,"./19.10.31-HTTP协议.md":203,"./19.10.31-HTTP状态码.md":207,"./19.11.01-ES6 Iterator.md":208,"./19.11.05-What is this.md":209,"./19.11.07-事件循环（Event Loop）.md":210,"./19.11.08-webpack 原理.md":213,"./19.11.09-TCP 和 UDP.md":215,"./19.11.18-认识了新伙伴-Svelte.md":216,"./19.11.21-mobx 和 redux.md":217,"./19.11.26-redux和koa中间件.md":218,"./19.11.26-十进制转换其他进制.md":219,"./19.11.27-微信小程序原理.md":220,"./19.11.29-使用vw进行移动端自适应布局.md":225,"./19.12.02-history.listen()-后台侧边栏根据路由选中.md":226,"./19.12.02-mac chorme跨域.md":227,"./19.12.06-小程序开发遇到的深坑.md":228,"./19.12.07-数据更新和管理tips.md":229,"./19.12.13-贴一段hooks的antd列表页.md":230,"./19.12.16-require.context.md":231,"./19.12.16-多页的一个坑-html模版引入的文件勿忘commom.md":232,"./19.12.16-设计思路-去中心化.md":233,"./19.12.17-利用require.context批量引入图片资源输出成组件.md":234,"./19.12.18-利用Suspense和lazy模块懒加载.md":235,"./19.12.18-还记得它吗.md":236,"./19.12.19-接口 定义返回结果原则.md":237,"./19.12.24-node 简易本地静态服务.md":238,"./19.12.25-antd script 标签引入 定制样式.md":239,"./19.12.26-object.defineProperty.md":240,"./20.01.06-react-router switch存在的意义.md":241,"./20.01.07-null 和 undefined的区别.md":242,"./20.01.09-写一套serverless—undo.md":243,"./20.01.11-Vue 和 mobx 观察者模式.md":244,"./20.01.11-getSearchParam.md":247,"./20.01.13-一道算法题-undo.md":248,"./20.01.13-前端缓存策略.md":249,"./20.01.14-gitlab cli.yml.md":250,"./20.01.14-一段shell.md":251,"./20.01.14-钉钉模块的插件化开发思路 或 小程序的思路.md":252,"./20.01.16-一个图片全屏预览组件.md":253,"./20.01.16-试试一个文本标注的本地场景.md":254,"./20.01.17-URL.createObjectURL.md":256,"./20.01.17-webpack plugin入门.md":257,"./20.01.17-匹配 dom 标签的正则.md":258,"./20.01.19-npm 包 一些注意记录.md":259,"./20.02.01-react-router switch标签存在的意义.md":260,"./20.02.08-antd form validateFields 不执行的一个原因.md":261,"./20.02.12-面试时，问自己做的好的点.md":262,"./20.02.25-async await.md":263,"./20.03.02-react-pdf.md":264,"./20.03.03-react 高阶组件.md":265,"./20.03.09-日志组件.md":266,"./20.04.02-Icons-一个获取生成icon组件的一套方案.md":267,"./20.04.21-call&apply及其他js源码实现.md":269,"./20.04.21-webpack plugin 扩展自Tapable的钩子函数.md":270,"./20.04.21-木桶布局和瀑布流布局.md":271,"./20.04.26-手写上传.md":272,"./20.04.26-文件流转 base64 FileReader.readAsDataURL().md":273,"./20.04.27-react fiber.md":274,"./20.04.27-setState.md":279,"./20.04.28-大数运算.md":280,"./20.04.28-斐波那契数列.md":281,"./20.04.29-找最少硬币数（动态规划）.md":282,"./20.04.29-计算数组的交集.md":283,"./20.05.06-js 被 V8引擎解析为机器语言.md":284,"./20.05.07-koa+react ssr 踩坑.md":285,"./20.05.09-js 基本数据类型.md":286,"./20.05.11-python pip 安装opencv-python.md":287,"./20.05.11-python pip 安装tensorflow.md":288,"./20.05.11-python pip 设置 阿里云 源 .md":289,"./20.05.11-python 下载cifar10.md":290,"./20.05.13-tf 一些函数.md":291,"./20.05.13-tf 结果 欠拟合 和 过拟合.md":292,"./20.05.13-tf.kares.md":293,"./20.05.19-处理树形数据.md":294,"./20.05.19-异位词.md":295,"./20.05.19-最大子和数.md":296,"./20.05.22-leetcode 1 两数之和.md":297,"./20.05.22-leetcode 2 两数相加.md":298,"./20.05.22-leetcode 3 无重复字符的最长子串.md":299,"./20.05.23-leetcode 4 寻找两个正序数组的中位数.md":300,"./20.05.25-leetcode 5 最长回文子串.md":301};function o(e){var n=a(e);return t(n)}function a(e){if(!t.o(r,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}o.keys=function(){return Object.keys(r)},o.resolve=a,e.exports=o,o.id=192},function(e,n){e.exports="<h3 id=坑啊>坑啊</h3> <p>wrong</p> <pre><code>useEffect(async () =&gt; {\n  setTableLoading(true)\n  try {\n    const res = await io.getUserList({\n      activityId,\n      phone,\n      userName,\n      currentPage,\n      pageSize,\n    })\n\n    setTotal(res.count)\n    setList(res.data)\n    setTableLoading(false)\n  } catch (e) {\n    setTableLoading(false)\n    message.error(e.message)\n  }\n}, [query])</code></pre><p>right</p> <pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    setTableLoading(true)\n    try {\n      const res = await io.getUserList({\n        activityId,\n        phone,\n        userName,\n        currentPage,\n        pageSize,\n      })\n\n      setTotal(res.count)\n      setList(res.data)\n      setTableLoading(false)\n    } catch (e) {\n      setTableLoading(false)\n      message.error(e.message)\n    }\n  }\n\n  fetchData()\n}, [query])\n</code></pre>"},function(e,n){e.exports="<h3 id=webpack4新手向>webpack4新手向</h3> <p>写自己配置webpack的经历 </p> <p>参考资料：<br><a href=https://www.webpackjs.com/guides/ >webpack 中文文档 指南栏</a><br><a href=https://webpack.js.org/guides/ >webpack 英文文档 指南栏</a><br>ps: 感觉 英文 Configuration 栏 看着舒服 知道 是哪个配置项</p> <h4 id=初始化webpack>初始化webpack</h4> <p>安装 webpack &amp; webpack-cli</p> <pre><code>npm init -y\nnpm install webpack webpack-cli --save-dev</code></pre><p>添加webpack配置文件 webpack.config.js</p> <pre><code>const path = require(&#39;path&#39;);\n\nmodule.exports = {\n  entry: &#39;./src/index.js&#39;,\n  output: {\n    filename: &#39;bundle.js&#39;,\n    path: path.resolve(__dirname, &#39;dist&#39;)\n  }\n}</code></pre><p>package.json 的 scripts 中添加 build 命令</p> <pre><code>&quot;build&quot;: &quot;webpack --mode production&quot;,</code></pre><p>这样 我们就可以 <em>npm run build</em> 打包我们的代码了</p> <p>根据上面的配置:<br>入口文件： <em>src/index.js</em><br>打包后的目录： <em>dist</em> </p> <pre><code>  |- package.json\n+ |- webpack.config.js\n  |- /dist\n    |- bundle.js\n  |- /src\n    |- index.js</code></pre><h4 id=添加html模版>添加html模版</h4> <p>我们打包生成的js文件需要配合html文件，可以生成web入口。<br>我们可以通过 webpack的plugins配置项，添加 html-webpack-plugin，生成一个html入口模版</p> <p>安装html-webpack-plugin依赖</p> <pre><code>npm i html-webpack-plugin -D</code></pre><p>修改webpack.config.js </p> <pre><code>const htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = {\n  ...\n  plugins: [\n    new HtmlwebpackPlugin({\n      title: &#39;title 参数 生成的html模板的title。但指定了 template 后 该参数无效！！！&#39;\n      filename: &#39;xxxx.html&#39;,   // build后html文件名\n      template: &#39;./src/index.html&#39;  // 入口html文件模板，不指定的话，会默认生成 一个html模版\n    })\n  ]\n}</code></pre><p><em>基本模版内容仅供参考</em> 需放到上面配置的template对应目录</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n  &lt;title&gt;React App&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>打包后的文件结构</p> <pre><code>  |- package.json\n  |- webpack.config.js\n  |- /dist\n    |- bundle.js\n  + |- xxx.html\n  |- /src\n    |- index.js</code></pre><h4 id=可以开始开发react了>可以开始开发React了</h4> <p>webpack-dev-server登场</p> <pre><code>npm i webpack-dev-server --save-dev</code></pre><p>安装React &amp; React-Dom</p> <pre><code>npm i react react-dom -S</code></pre><p>package.json 的 scripts 中添加 start 命令</p> <pre><code>&quot;start&quot;: &quot;webpack-dev-server --mode development --open --hot&quot;,</code></pre><p>这样 我们就可以 <em>npm start</em> 本地开发我们的项目了</p> <p>在src下 添加以下文件看看效果吧 <em>src/index.js</em></p> <pre><code>import React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nimport App from &#39;./components/app&#39;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;app&#39;))</code></pre><p><em>src/components/app.js</em></p> <pre><code>import React, { Component } from &#39;react&#39;\n\nexport default class App extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        test \n      &lt;/div&gt;\n    )\n  }\n}</code></pre><h4 id=添加-babel>添加 babel</h4> <p>安装依赖 <em>@babel/core @babel/preset-env @babel/preset-react</em></p> <pre><code>npm install --save-dev @babel/core @babel/preset-env @bable/preset-react</code></pre><p>添加 .babelrc 配置文件</p> <pre><code>// targets, useBuiltIns 等选项用于编译出兼容目标环境的代码\n// 其中 useBuiltIns 如果设为 &quot;usage&quot;\n// Babel 会根据实际代码中使用的 ES6/ES7 代码，以及与你指定的 targets，按需引入对应的 polyfill\n// 而无需在代码中直接引入 import &#39;@babel/polyfill&#39;，避免输出的包过大，同时又可以放心使用各种新语法特性。\n// 还需要指定corejs 版本\n{\n  &quot;presets&quot;: [\n    [\n      &quot;@babel/preset-env&quot;,\n      {\n        {\n          &quot;modules&quot;: false,\n          &quot;targets&quot;: {\n            &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]\n          },\n          &quot;useBuiltIns&quot;: &quot;usage&quot;,\n          &quot;corejs&quot;: 2\n        } \n      }\n    ],\n    &quot;@babel/preset-react&quot;\n  ]\n}</code></pre>"},function(e,n){e.exports="<h4 id=新的开始>新的开始</h4> <ul> <li>拥抱变化</li> <li>满怀信心</li> <li>HAPPY </li> </ul> "},function(e,n){e.exports="<h3 id=webpack4reactbabel-踩坑>webpack4+react+babel 踩坑</h3> <p>自己踩坑的经历 </p> <h4 id=react-router>react-router</h4> <p>issue: 定义的 BrowserRouter, 路由刷新 报 cannot get /xxx</p> <p>answer: </p> <ul> <li><p>本地webpack 配置 </p> <pre><code>devServer: {\n  historyApiFallback: true,\n}</code></pre><p><em>只适合开发环境中进行配置</em> <em>线上环境需要服务器支持</em></p> </li> <li><p>BrowserRouter 改为 HashRouter </p> <ol> <li>路由会有 # 号，影响美观</li> <li>不能使用服务器渲染</li> </ol> </li> </ul> <h4 id=babel7>Babel7</h4> <p>issue: Support for the experimental syntax &#39;classProperties&#39; isn&#39;t currently enabled </p> <p>answer: </p> <pre><code>npm i -D @babel/plugin-proposal-class-properties\n\n\n配置.babelrc \n\n{ \n  &quot;plugins&quot;: [ \n    [\n      &quot;@babel/plugin-proposal-class-properties&quot;, \n      { &quot;loose&quot;: true }\n    ] \n  ] \n}   \n</code></pre><p>issue: babel 在每个文件都插入了辅助代码，使代码体积过大！</p> <p>answer: </p> <pre><code>你必须执行 \nnpm install @babel/plugin-transform-runtime --save-dev 来把它包含到你的项目中，也要使用 \nnpm install babel-runtime --save-dev 把 babel-runtime 安装为一个依赖\n\n修改.babelrc\n\n&quot;plugins&quot;: [\n  ...\n  &quot;@babel/transform-runtime&quot;,\n  ...\n]</code></pre><p>issue: this.setDynamic is not a function</p> <p>answer: </p> <pre><code>babel7-\nnpm install babel-plugin-transform-runtime --save-dev\n\nbabel7+ 插件 修改\nnpm install @babel/plugin-transform-runtime --save-dev</code></pre><p>issuce: export &#39;default&#39; (imported as &#39;xxx&#39;) was not found in &#39;xxx&#39; </p> <p>answer: </p> <pre><code>babel 自身没有将 es6 的代码编译成 es5\nnpm install @babel/plugin-transform-modules-commonjs -D</code></pre>"},function(e,n){e.exports="<h3 id=搭建自己的github-page>搭建自己的Github Page</h3> <p>有两种方式</p> <ul> <li><p>创建一个 username.github.io repo<br>创建一个 index.md / index.html 路径 在 <code>https://username.github.io</code></p> </li> <li><p>创建一个 xxx repo<br>创建一个 index.md / index.html<br>setting 下 选择 github page 打开 page 功能 路径 在 <code>https://username.github.io/xxx</code></p> </li> </ul> <blockquote> <p>master 分支下 默认 读取 index 文件 作为 根路由。</p> </blockquote> <blockquote> <p>Github Page 的路由规则 是 托管 master 根目录下的 xxx.md(html)，对应 <code>https://username.github.io/xxx</code>。 </p> </blockquote> <blockquote> <p>index除外，index文件默认根路由。</p> </blockquote> <h4 id=这样我们-就可以-将我们-通过脚手架-build-后的文件-托管到-git-查看效果了>这样我们 就可以 将我们 通过脚手架 build 后的文件 托管到 git 查看效果了</h4> <p>我们的 单页面应用 路由 建议使用 HashRouter，因为 BroswerRouter 有问题</p> <p>ps: 等着看看是否解决 和 如何解决</p> <h4 id=我的经验>我的经验</h4> <h5 id=stage-1-本着各各代码库-各司其职的原则>stage 1: 本着各各代码库 各司其职的原则</h5> <pre><code>step 1:\n\ngit clone https://github.com/xxx/xxx.github.io.git  \n初始化 我们的 Github Pages 的本地库  \n\nstep 2:\n\n新建另一个开发代码库   \n初始化 开发框架 开发完 npm run build 生成 dist 目录\n\nstep 3:\n\n将 dist 目录下 的 文件 复制到 Github Page 库下 更新</code></pre><p><em>我的心路历程@1</em> </p> <blockquote> <p>init github-page-repo -&gt; init work-repo -&gt; work done -&gt; build -&gt; move dist to github-page-repo -&gt; update</p> </blockquote> <p>大写的心累</p> <h5 id=stage-2-聪明一点的我，把开发库改成了-github-page-库下的-开发分支>stage 2: 聪明一点的我，把开发库改成了 Github Page 库下的 开发分支</h5> <pre><code>step 1:\n\ngit clone https://github.com/xxx/xxx.github.io.git  \n初始化 我们的 Github Pages 的本地库  \n\nstep 2:\ngit checkout -b dev\n新建另一个开发分支 \n初始化 开发框架 开发完 npm run build 生成 dist 目录\n\nstep 3:\n\n将 dist 目录下 的 文件 复制到 master 分支 更新</code></pre><p><em>我的心路历程@2</em></p> <blockquote> <p>init github-page-repo -&gt; checkout dev-branch -&gt; work done -&gt; build -&gt; move dist to master -&gt; update</p> </blockquote> <p>虽然依旧心累但是 只维护 一个库 不用 切文件夹 了，但是要切分支</p> <p><em>我的心路历程@2.1</em></p> <p>干嘛不用个脚本！！！</p> <blockquote> <p>添加 deploy.sh 一键 ./deploy.sh 部署发布</p> </blockquote> <pre><code class=language-shell>npm run build\ngit checkout master\nrm -rf index.html\nrm -rf *.js\nrm -rf *.css\nmv dist/* ./\ngit add .\ngit commit -m &#39;commit message&#39;\ngit push origin master\ngit checkout dev</code></pre> <p>Because of Lan, I become stronger!!!</p> "},function(e,n){e.exports="<h3 id=webpack-配置打包优化>webpack 配置打包优化</h3> <h4 id=样式提取及压缩>样式提取及压缩</h4> <p><em>mini-css-extract-plugin</em> 将css文件提取成一个文件 <em>optimize-css-assets-webpack-plugin</em> 压缩css文件</p> <pre><code>mini-css-extract-plugin 将css文件提取成一个文件\n\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;) // css 并合并成 文件\n\nmodule: {\n  rules: [\n    {\n      test: /\\.(le|c)ss$/,\n      use: [\n        // 添加 环境判断 变量 只有生产环境 使用 MiniCssExtractPlugin\n        isDEV ? &#39;style-loader&#39; : MiniCssExtractPlugin.loader,\n        &#39;css-loader&#39;, \n        { \n          loader: &#39;postcss-loader&#39;,\n          options: {\n            plugins: loader =&gt; [\n              require(&#39;autoprefixer&#39;)(), // CSS浏览器兼容 需要package.json 添加 对应的 browserslist,也有其他方式，自行搜索\n            ]\n          }\n        },\n        `less-loader?{&quot;sourceMap&quot;:true, &quot;modifyVars&quot;:${JSON.stringify(theme)}, &quot;javascriptEnabled&quot;: true}`,\n      ], // 注意排列顺序，执行顺序与排列顺序相反\n    },\n  ],\n}\n\nplugins: [\n  ...,\n  ...(isDEV ? \n    []\n    : [\n      new MiniCssExtractPlugin({\n        filename: &#39;[name].css&#39;,\n        // 将相关模块的 样式分离，生成不同的文件，按需加载 css下载变小，加快页面加载\n        chunkFilename: &#39;[name].[contenthash].css&#39; \n      }),\n    ]\n  ),\n  ...,\n],\n\noptimize-css-assets-webpack-plugin 压缩css文件\n\noptimization: {\n  minimizer: [\n    // 混淆 js\n    new UglifyJsPlugin({\n      uglifyOptions: {\n        compress: {\n          drop_console: true,\n        },\n        ecma: 5,\n      },\n      cache: true,\n      parallel: true,\n      sourceMap: true,\n    }),\n    // 压缩css\n    new OptimizeCSSAssetsPlugin({\n      assetNameRegExp: /\\.css$/g,\n      cssProcessorOptions: {\n        // const safeParser = require(&#39;postcss-safe-parser&#39;) 添加前缀的规则\n        parser: safeParser, \n        discardComments: {\n          removeAll: true,\n        },\n      },\n    }),\n  ],\n},</code></pre><h4 id=js模块打包拆分>js模块打包拆分</h4> <h5 id=commonjs-提取>common.js 提取</h5> <pre><code>optimization: {\n  splitChunks: {\n    cacheGroups: {\n      common: {\n        test: /[\\\\/]node_modules[\\\\/] || src\\//,\n        chunks: &#39;all&#39;,\n        name: &#39;common&#39;,\n        minSize: 0,\n        minChunks: 2,\n        priority: 10, //优先级\n        enforce: true,\n      },\n    },\n  },\n}</code></pre><h5 id=react、react-dom、react-router-dom-等公用模块-走cdn>react、react-dom、react-router-dom 等公用模块 走CDN</h5> <blockquote> <p>将我们用到的依赖 通过外部cdn的方式引入，打包时不打包，减少打包体积大小，将它们从package.json里面删掉</p> </blockquote> <pre><code>externals: {\n  react: &#39;React&#39;,\n  &#39;react-dom&#39;: &#39;ReactDOM&#39;,\n  &#39;react-router-dom&#39;: &#39;ReactRouterDOM&#39;,\n},\nplugins: [\n  ...,\n  new HtmlWebpackPlugin({\n    jsCdns: [\n      &#39;https://cdn.jsdelivr.net/npm/react@16.10.2/umd/react.production.min.js&#39;,\n      &#39;https://cdn.jsdelivr.net/npm/react-dom@16.10.2/umd/react-dom.production.min.js&#39;,\n      &#39;https://cdn.jsdelivr.net/npm/react-router-dom@5.1.2/umd/react-router-dom.min.js&#39;,\n    ],\n    template: &#39;./template/index.html&#39;,\n    minify: {\n      collapseWhitespace: true, // 折叠空白\n      removeComments: true, // 移除注释\n      removeAttributeQuotes: true // 移除属性的引号\n    }\n  }),\n  ...,\n],</code></pre><p><em>模版对应修改</em></p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n  &lt;title&gt;suyunlonsy&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n\n  &lt;% htmlWebpackPlugin.options.jsCdns.map(item =&gt; {{ %&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%= item %&gt;&quot;&gt;&lt;/script&gt;\n  &lt;% }}) %&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><h4 id=配置-resolve-优化-加载解析速度>配置 resolve 优化 加载解析速度</h4> <pre><code>resolve: {\n  alias: {\n    src: resolve(&#39;src&#39;),\n    common: resolve(&#39;src/common&#39;),\n    images: resolve(&#39;src/images&#39;),\n    markdowns: resolve(&#39;src/markdowns&#39;),\n    mods: resolve(&#39;src/components&#39;),\n  },\n  extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;css&#39;]\n},</code></pre>"},function(e,n,t){var r=t(100),o=t(200),a=t(201),i="<h4 id=瞎搞webhook>瞎搞webhook</h4> <blockquote> <p>Webhooks是GitHub提供的一个API。Webhooks可以在GitHub仓库(repositories)发生事件(比如提交代码,创建分支，发布版本)时，通知到其他服务器。Webhook实质上就是一个callback</p> </blockquote> <h5 id=在github中设置项目的webhook>在GitHub中设置项目的webhook</h5> <ol> <li><p>进入 GitHub 代码库，依次点击「Settings」、「Webhooks &amp; Services」、「Add Webhook」 <img src="+r(o)+' alt="alt 仓库setting页"></p> </li> <li><p>填入对应的Webhook地址，即可完成配置 <img src='+r(a)+' alt="alt 仓库setting页"></p> </li> </ol> <h5 id=神奇的工具>神奇的工具</h5> <p><a href=https://ngrok.com/ >公网映射工具 ngrok</a></p> ';e.exports=i},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/webhook-setting.jpg?baa3085bdd76e99095ec48a3fbd94ad0"},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/webhook-config.jpeg?dddaaf25a643550eea46893565faa392"},function(e,n){e.exports="<pre><code>// 题目：\n// 以 provinces 为数据源，设计并实现区域选择组件 RegionSelect\n// 要求：确保 Demo 能够正常使用 RegionSelect\n// 具体包含：\n// 1. Demo 向 RegionSelect 传值能够正确渲染\n// 2. Demo 中的 handleRegionChange 能够正确输出\n// 3. 考虑 RegionSelect 组件的通用性\n\nimport React, { Component } from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\nimport &quot;antd/dist/antd.css&quot;;\nimport &quot;./index.css&quot;;\nimport { Select } from &quot;antd&quot;;\n\nconst { Option } = Select;\n\nconst provinces = [\n  {\n    name: &quot;浙江省&quot;,\n    code: 1,\n    cities: [\n      {\n        name: &quot;杭州市&quot;,\n        code: 11,\n        areas: [{ name: &quot;西湖区&quot;, code: 111 }, { name: &quot;余杭区&quot;, code: 112 }]\n      },\n      {\n        name: &quot;宁波市&quot;,\n        code: 12,\n        areas: [{ name: &quot;江北区&quot;, code: 121 }, { name: &quot;江东区&quot;, code: 122 }]\n      }\n    ]\n  },\n  {\n    name: &quot;广东省&quot;,\n    code: 2,\n    cities: [\n      {\n        name: &quot;广州市&quot;,\n        code: 21,\n        areas: [{ name: &quot;白云区&quot;, code: 211 }, { name: &quot;天河区&quot;, code: 212 }]\n      },\n      {\n        name: &quot;深圳市&quot;,\n        code: 22,\n        areas: [{ name: &quot;宝安区&quot;, code: 221 }, { name: &quot;南山区&quot;, code: 222 }]\n      }\n    ]\n  }\n];\n\n// 完善组件功能\nclass RegionSelect extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;Select /&gt;省\n        &lt;Select /&gt;市\n        &lt;Select /&gt;区\n      &lt;/div&gt;\n    );\n  }\n}\n\n// 确保 RegionSelect 在以下 Demo 中能够正常运行\nclass Demo extends Component {\n  state = {\n    value: [1, 11, 111]\n  };\n\n  handleRegionChange(value) {\n    console.log(value);\n  }\n\n  render() {\n    const { value } = this.state;\n    return &lt;RegionSelect value={value} /&gt;;\n  }\n}\n\nReactDOM.render(&lt;Demo /&gt;, document.getElementById(&quot;container&quot;));\n</code></pre><p><a href=http://suyunlongsy.github.io/#/region-select>自己写的组件</a></p> "},function(e,n,t){var r=t(100),o=t(204),a=t(205),i=t(206),s="<h2 id=http-协议>HTTP 协议</h2> <p><img src="+r(o)+' alt="alt 模拟流程图"></p> <h3 id=请求>请求</h3> <blockquote> <p>一个http请求由<em>请求行</em>，<em>请求头</em>，<em>空行</em>，<em>请求主体</em>组成</p> </blockquote> <p><img src='+r(a)+' alt="alt HTTP Request"></p> <h4 id=请求头中的请求方式（http11新增5种）：>请求头中的请求方式（http/1.1新增5种）：</h4> <ul> <li>GET 请求指定的页面信息，并返回实体主体</li> <li>HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li> <li>POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li> <li>PUT 从客户端向服务器传送的数据取代指定的文档的内容。</li> <li>DELETE 请求服务器删除指定的页面。</li> </ul> <h3 id=响应>响应</h3> <blockquote> <p>一个http响应由<em>状态行</em>，<em>响应头</em>，<em>空行</em>，<em>响应主体</em>组成</p> </blockquote> <p><img src='+r(i)+' alt="alt HTTP Response"></p> <h4 id=响应头>响应头</h4> <ul> <li>Content-Disposition：附件只需要把文件名给过去就可以，这个名称就是下载时显示的文件名称</li> <li>content-type：文件类型</li> </ul> <h4 id=状态码>状态码</h4> <p><a href=https://suyunlongsy.github.io/#/detail/19.10.31-HTTP状态码.md>戳我查看</a></p> <h3 id=http工作原理>HTTP工作原理</h3> <ol> <li><p>客户端连接到Web服务器</p> <blockquote> <p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接 （TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket））</p> </blockquote> </li> <li><p>发送HTTP请求</p> <blockquote> <p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p> </blockquote> </li> <li><p>服务器接受请求并返回HTTP响应</p> <blockquote> <p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p> </blockquote> </li> <li><p>释放连接TCP连接</p> <blockquote> <p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求</p> </blockquote> </li> </ol> <blockquote> <p><a href="https://baike.baidu.com/item/TCP/33012?fr=aladdin#6">TCP工作方式</a></p> </blockquote> <ol start=5> <li>客户端浏览器解析HTML内容<blockquote> <p>客户端浏览器首先<em>解析状态行</em>，查看表明请求是否成功的<em>状态码</em>。然后解析每一个<em>响应头</em>，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p> </blockquote> </li> </ol> <h3 id=在浏览器地址栏输入url按回车后经历的流程>在浏览器地址栏输入URL按回车后经历的流程</h3> <p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p> <p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p> <p>3、浏览器发出读取文件(URL中域名后面部分对应的文件)的HTTP 请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器;</p> <p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p> <p>5、释放TCP连接;</p> <p>6、浏览器将该 html 文本并显示内容;</p> ';e.exports=s},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/HTTP-simulated-interaction-diagram.png?25448cb50f9be31ebe93502397d58efe"},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/HTTP-Request.png?2ebbea521fd2ca70f214209e471e4fd4"},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/HTTP-Response.png?d94726044b55ae6048edafa9c0c2b5dd"},function(e,n){e.exports="<h4 id=http-状态码>HTTP 状态码</h4> <table> <thead> <tr> <th align=left></th> <th align=left>类别</th> <th align=left>原因短语</th> </tr> </thead> <tbody><tr> <td align=left>1XX</td> <td align=left>Informational（信息性状态码）</td> <td align=left>接受的请求正在处理</td> </tr> <tr> <td align=left>2XX</td> <td align=left>Success（成功状态码）</td> <td align=left>请求正常处理完毕</td> </tr> <tr> <td align=left>3XX</td> <td align=left>Redirection（重定向状态码）</td> <td align=left>需要进行附加操作以完成请求</td> </tr> <tr> <td align=left>4XX</td> <td align=left>Client Error（客户端错误状态码）</td> <td align=left>服务器无法处理请求</td> </tr> <tr> <td align=left>5XX</td> <td align=left>Server Error（服务器错误状态码）</td> <td align=left>服务器处理请求出错</td> </tr> </tbody></table> <ul> <li><em>2XX——表明请求被正常处理了</em></li> <li><em>3XX——表明浏览器需要执行某些特殊的处理以正确处理请求</em></li> <li><em>4XX——表明客户端是发生错误的原因所在</em></li> <li><em>5XX——服务器本身发生错误</em></li> </ul> <h4 id=2xx>2XX</h4> <pre><code>200 OK：请求已正常处理。</code></pre><h4 id=3xx>3XX</h4> <pre><code>301 Moved Permanently ：客户端对该资源进行了缓存，服务端返回空，客户端直接从缓存中读取对应资源。（响应头中包含了Last-Modified或ETag）\n302 Found：请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n304 Not Modified：客户端对该资源进行了缓存，服务端返回空，客户端直接从缓存中读取对应资源。（响应头中包含了Last-Modified或ETag）</code></pre><h5 id=301重定向和302重定向的区别>301重定向和302重定向的区别</h5> <pre><code>302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。\n\n而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。</code></pre><h4 id=4xx>4XX</h4> <pre><code>400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。\n\n401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。\n\n403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）\n\n404 Not Found：服务器上没有请求的资源。路径错误等。</code></pre><h4 id=5xx>5XX</h4> <pre><code>500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。\n\n503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求</code></pre>"},function(e,n){e.exports="<h2 id=iterator>Iterator</h2> <blockquote> <p>JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p> </blockquote> <blockquote> <p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p> </blockquote> <blockquote> <p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。</p> </blockquote> <blockquote> <p>Iterator 的遍历过程是这样的。</p> </blockquote> <blockquote> <p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p> </blockquote> <blockquote> <p>（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</p> </blockquote> <blockquote> <p>（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</p> </blockquote> <blockquote> <p>（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。</p> </blockquote> <blockquote> <p>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p> </blockquote> <pre><code>常见的具有Iterator接口的遍历器:\n　　Array\n　　Map\n　　Set\n　　String\n　　TypedArray\n　　函数的 arguments 对象\n　　NodeList 对象\n　　生成器</code></pre>"},function(e,n){e.exports="<h2 id=what-is-this>What is this</h2> <h4 id=普通函数中的this>普通函数中的this</h4> <p>普通函数，this的概念是：this是JavaScript的一个关键字，他是指函数执行过程中，自动生成的一个内部对象，是指当前的对象，只在当前函数内部使用。（this对象是在运行时基于<code>函数的执行环境</code>绑定的：在全局函数中，this指向的是window；当函数被作为<code>某个对象的方法</code>调用时，this就等于那个对象）。</p> <h4 id=箭头函数的this>箭头函数的this</h4> <p>箭头函数的this是在<code>定义函数</code>时绑定的，不是在执行过程中绑定的。简单的说，函数在定义时，this就继承了定义函数的对象。</p> <p>比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题</p> <h4 id=bind-call-apply>bind call apply</h4> <blockquote> <p>作用都是改变函数运行时上下文（this指向）而存在的</p> </blockquote> <p>区别</p> <ul> <li>接收的第一个参数都是要绑定的this 指向</li> <li>apply 的 第二个参数 是一个 参数数组，call和bind的第二个及之后的参数作为函数士参按顺序传入</li> <li>bind 不会立即调用，其他两个会立即调用</li> </ul> <h4 id=es6-简易实现>es6 简易实现</h4> <p>call</p> <pre><code>Function.prototype.call = function(context) {\n  const ctx = context || window\n\n  // 将当前被调用的方法定义在cxt.func上。（为了能以对象调用的形式绑定this）\n  ctx.func = this\n\n  // 获取实参\n  const args = Array.from(arguments).slice(1)\n\n  // 以对象调用的 形式 调用func，此时this指向ctx，也就是传入的需要绑定的this指向\n  const res = arguments.length &gt; 1 ? ctx.fun(...args) : ctx.fun()\n\n  // 删除该方法，不然会对传入的对象造成污染（添加该方法）\n  delete ctx.func\n\n  return res\n}</code></pre><p>apply</p> <pre><code>Function.prototype.apply = function(context) {\n  const ctx = context || window\n\n  ctx.func = this\n\n  const res = arguments[1] ? ctx.func(...arguments[1]) : ctx.func()\n\n  delete ctx.func\n\n  return res\n}</code></pre><p>bind</p> <pre><code>Function.prototype.bind = function(context) {\n  // 对context进行深拷贝，防止污染\n  const ctx = JSON.parse(JSON.stringify(context)) || window\n\n  // 将当前被调用的方法定义在cxt.func上。（为了能以对象调用的形式绑定this） \n  ctx.func = this\n\n  const args = Array.from(arguments).slice(1)\n\n  return function() {\n    // 这里注意一点的是需要对bind函数的实参和返回的的绑定函数的实参进行参数合并，调用时传入！\n    const allArgs = args.concat(Array.from(arguments))\n\n    // 以对象的方式调用func，此时this指向ctx，也就是传入的需要被绑定的this指向\n    return allArgs.length &gt; 0 ? ctx.func(...allArgs) : ctx.func()\n  } \n}</code></pre>"},function(e,n,t){var r=t(100),o=t(211),a=t(212),i="<h2 id=事件循环（event-loop）>事件循环（Event Loop）</h2> <blockquote> <p>Event Loop即事件循环，是解决javaScript单线程运行阻塞的一种机制。</p> </blockquote> <blockquote> <p>一个例子开胃</p> </blockquote> <pre><code>//请写出输出内容\nasync function async1() {\n    console.log(&#39;async1 start&#39;);\n    await async2();\n    console.log(&#39;async1 end&#39;);\n}\nasync function async2() {\n    console.log(&#39;async2&#39;);\n}\n\nconsole.log(&#39;script start&#39;);\n\nsetTimeout(function() {\n    console.log(&#39;setTimeout&#39;);\n}, 0)\n\nasync1();\n\nnew Promise(function(resolve) {\n    console.log(&#39;promise1&#39;);\n    resolve();\n}).then(function() {\n    console.log(&#39;promise2&#39;);\n});\nconsole.log(&#39;script end&#39;);\n\n\n/*\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n*/</code></pre><h3 id=一执行栈、事件队列和事件循环原理>一.执行栈、事件队列和事件循环原理</h3> <h4 id=eventloop的相关概念>EventLoop的相关概念</h4> <p>1、堆（Heap） 堆表示一大块非结构化的内存区域，对象，数据被存放在堆中</p> <p>2、栈（Stack） 栈在javascript中又称执行栈，调用栈，是一种后进先出的数组结构， Javascript 有一个 主线程（main thread）和 调用栈(或执行栈call-stack)，主线各所有的任务都会被放到调用栈等待主线程执行。 JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p> <p>3、队列（Queue） 队列即任务队列Task Queue，是一种先进先出的一种数据结构。在队尾添加新元素，从队头移除元素。</p> <p>当javascript代码执行的时候会将不同的变量存于内存中的不同位置：<code>堆（heap）</code>和<code>栈（stack）</code>中来加以区分。其中，堆里存放着一些<code>对象</code>。而栈中则存放着一些<code>基础类型变量</code>以及对象的<code>指针</code>。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p> <p>我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的<code>执行环境（context）</code>，又叫``执行上下文<code>。这个执行环境中存在着这个方法的</code>私有作用域<code>，</code>上层作用域的指向，方法的参数<code>，这个作用域中定义的</code>变量<code>以及这个作用域的</code>this对象`。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为<strong>执行栈</strong>。</p> <p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么<code>js会向执行栈中添加这个方法的执行环境</code>，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，<code>js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境</code>。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p> <p>一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p> <p>以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？前文提过，js的另一大特点是<code>非阻塞</code>，实现这一点的关键在于下面要说的这项机制——<strong>事件队列（Task Queue）</strong>。</p> <p>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。 当这个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为<strong>事件队列（任务队列）</strong>。 被放入事件队列不会立刻执行其回调，而是<code>等待当前执行栈中的所有任务都执行完毕</code>， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。 如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p> <h4 id=同步任务和异步任务>同步任务和异步任务</h4> <p>javascript是单线程。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 于是js所有任务分为两种：同步任务，异步任务 <strong>同步任务</strong>是调用立即得到结果的任务，同步任务在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p> <p><strong>异步任务</strong>是调用无法立即得到结果，需要额外的操作才能预期结果的任务，异步任务不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p> <p>JS引擎遇到异步任务（DOM事件监听、网络请求、setTimeout计时器等），会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 事件触发线程 将异步对应的 回调函数 加入到消息队列中，消息队列中的回调函数等待被执行。</p> <p>具体来说，异步运行机制如下：</p> <p>（1）所有同步任务都在主线程上执行，形成一个[执行栈]</p> <p>（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</p> <p>（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p> <p>（4）主线程不断重复上面的第三步。</p> <p><img src="+r(o)+' alt="alt event loop"></p> <h4 id=宏任务和微任务>宏任务和微任务</h4> <pre><code>console.log(&#39;script start&#39;)\n\nsetTimeout(function() {\n    console.log(&#39;timer over&#39;)\n}, 0)\n\nPromise.resolve().then(function() {\n    console.log(&#39;promise1&#39;)\n}).then(function() {\n    console.log(&#39;promise2&#39;)\n})\n\nconsole.log(&#39;script end&#39;)\n\n// script start\n// script end\n// promise1\n// promise2\n// timer over</code></pre><p>&quot;promise 1&quot; &quot;promise 2&quot; 在 &quot;timer over&quot; 之前打印了？ 这里有一个新概念：macrotask（宏任务） 和 microtask（微任务）。</p> <p>所有任务分为宏任务（macrotask ）和微任务（microtask ） 两种。 MacroTask（宏任务）：* script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。</p> <p>MicroTask（微任务）：* Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver（具体使用方式查看这里）</p> <p>在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 宏任务 的队列中取出第一个任务，执行完毕后取出 微任务 队列中的所有任务顺序执行；之后再取 宏任务，周而复始，直至两个队列的任务都取完。</p> <p><img src='+r(a)+' alt="alt event loop"></p> <h4 id=总结>总结</h4> <p>浏览器中的事件循环机制较为简单，如果将主线程也看成一个宏任务的话，那么浏览器的事件循环可看作依次执行一下两点：</p> <ul> <li>从宏任务队列中取出一个宏任务执行</li> <li>清空微任务<pre><code>while(true) {\n  宏任务队列.shift()\n  微任务队列全部任务\n}</code></pre></li> </ul> <p>tips：</p> <ul> <li>宏任务队列和微任务队列都遵循先进先出的原则，先被加入队列的任务优先被取出执行</li> <li>Promise对象的resolve部分不是微任务，then 和 catch 部分才是<pre><code>setTimeout(function(){\nconsole.log(&#39;1&#39;)\n});\n</code></pre></li> </ul> <p>new Promise(function(resolve){ console.log(&#39;2&#39;); resolve(); }).then(function(){ console.log(&#39;3&#39;) });</p> <p>console.log(&#39;4&#39;);</p> <p>答案：2 4 3 1</p> <pre><code>* 微任务执行过程中产生的新的微任务追加到`当前`微任务队列队尾等待本轮事件循环执行\n* await方法返回的是一个Promise对象，因此await方法执行完毕，后续代码都应归入微任务队列\n* Node环境的事件循环与浏览器不完全一致\n</code></pre>';e.exports=i},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/event-loop.png?4118d4c68c99261a62da7dc7348d0fce"},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/macrotask&microtask.png?0cdc3655c0c204c2f2f27e1f1947747f"},function(e,n,t){var r="<h3 id=webpack-打包原理>webpack 打包原理</h3> <ol> <li>读取文件分析模块依赖</li> <li>对模块进行解析执行（深度遍历）</li> <li>针对不同的模块使用相应的loader</li> <li>编译模块，生成抽象语法树（AST）</li> <li>循环遍历AST树，拼接js</li> </ol> <h3 id=loader-原理>loader 原理</h3> <blockquote> <p>loader 本质是一个函数，输入参数是一个字符串，输出参数也是一个字符串。当然，输出的参数会被当成js代码，从而被 esprima 解析成 AST，触发进一步的依赖解析。</p> </blockquote> <blockquote> <p>webpack 会从右到左的顺序执行loader </p> </blockquote> <h3 id=webpack-热更新原理>webpack 热更新原理</h3> <p><img src="+t(100)(t(214))+' alt="alt webpack热更新"></p> <p>Server端使用webpack-dev-server去启动本地服务，内部实现主要使用了webpack、express、websocket。</p> <ul> <li><p>使用express启动本地服务，当浏览器访问资源时对此做响应。</p> </li> <li><p>服务端和客户端使用websocket实现长连接</p> </li> <li><p>webpack监听源文件的变化，即当开发者保存文件时触发webpack的重新编译。</p> <ul> <li>每次编译都会生成hash值、已改动模块的json文件、已改动模块代码的js文件</li> <li>编译完成后通过socket向客户端推送当前编译的hash戳</li> </ul> </li> <li><p>客户端的websocket监听到有文件改动推送过来的hash戳，会和上一次对比</p> <ul> <li>一致则走缓存</li> <li>不一致则通过ajax和jsonp向服务端获取最新资源</li> </ul> </li> <li><p>使用内存文件系统去替换有修改的内容实现局部刷新</p> </li> </ul> ';e.exports=r},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/webpack-hot-update.jpeg?8f080e546137615695957216d80e765c"},function(e,n){e.exports="<h3 id=tcp-和-udp>TCP 和 UDP</h3> <h4 id=tcp和udp的优缺点>TCP和UDP的优缺点</h4> <ul> <li>TCP<ul> <li>缺点：<ul> <li>[1] 三次握手四次挥手，传输更多包，浪费一些带宽</li> <li>[2] 为了进行可靠通信，双方都要维持在线，通信过程中服务器server可能出现非常大的并发连接，浪费了系统资源，甚至会出现宕机</li> <li>[3] 确认重传也会浪费一些带宽，且在不好的网络中，会不断的断开和连接，降低了传输效率</li> </ul> </li> </ul> </li> <li>UDP<ul> <li>优点：<ul> <li>[1] 没有握手，起步快延时小</li> <li>[2] 不需要维持双方在线，server不用维护巨量并发连接，节省了系统资源</li> <li>[3] 没有重传机制，在不影响使用的情况下，能更高效的利用网络带宽</li> </ul> </li> </ul> </li> </ul> <h4 id=tcp相比udp为什么是可靠的>TCP相比UDP为什么是可靠的</h4> <ol> <li>确认和重传机制 <blockquote> <p>建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础 传输过程中，如果Checksum校验失败、丢包或延时，发送端重传</p> </blockquote> </li> <li>数据排序 <blockquote> <p>TCP有专门的序列号SN字段，可提供数据re-order</p> </blockquote> </li> <li>流量控制<blockquote> <p>窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量</p> </blockquote> </li> <li>拥塞控制<blockquote> <p>TCP的拥塞控制由4个核心算法组成。<br> “慢启动”（Slow Start） “拥塞避免”（Congestion avoidance） “快速重传 ”（Fast Retransmit） “快速恢复”（Fast Recovery）</p> </blockquote> </li> </ol> "},function(e,n){e.exports="<h3 id=svelte>Svelte</h3> <p><a href=https://svelte.dev/ >who am i</a></p> "},function(e,n){e.exports="<h3 id=mobx--redux>mobx &amp; redux</h3> <blockquote> <p>传统React使用的数据管理库为Redux。Redux要解决的问题是统一数据流，数据流完全可控并可追踪。要实现该目标，便需要进行相关的约束。Redux由此引出了dispatch action reducer等概念，对state的概念进行强约束。然而对于一些项目来说，太过强，便失去了灵活性。Mobx便是来填补此空缺的。</p> </blockquote> <p>Mobx的核心原理是通过action触发state的变化，进而触发state的衍生对象（computed value &amp; Reactions）</p> <p>在redux中，唯一可以更改state的途径便是dispatch一个action。这种约束性带来的一个好处是可维护性。整个state只要改变必定是通过action触发的，对此只要找到reducer中对应的action便能找到影响数据改变的原因。</p> <h4 id=mobx原理分析>Mobx原理分析</h4> <p>Mobx的核心就是通过observable观察某一个变量，当该变量产生变化时，对应的autorun内的回调函数就会发生变化。Mobx是通过代理变量的getter和setter来实现的变量更新功能。首先先代理变量的getter函数，然后通过预执行一遍autorun中回调，从而触发getter函数，来实现观察值的收集，依次来代理setter。之后只要setter触发便执行收集好的回调就ok了。</p> <h4 id=redux>Redux</h4> <p>Redux是将整个应用状态存储到一个地方上称为store,里面保存着一个状态树store tree,组件可以派发(dispatch)行为(action)给store,而不是直接通知其他组件，组件内部通过订阅store中的状态state来刷新自己的视图。</p> "},function(e,n){e.exports="<h3 id=koa--redux-中间件>Koa &amp; Redux 中间件</h3> <p>koa 是 洋葱模型 app.use 触发一遍 执行时 反向触发一遍</p> <p>redux 是 半洋葱模型</p> "},function(e,n){e.exports="<h3 id=十进制转换其他进制>十进制转换其他进制</h3> <pre><code>const num = 100\nconsole.log(num.toString(2))\nconsole.log(num.toString(8))\nconsole.log(num.toString(16))\nconsole.log(num.toString(32))\nconsole.log(num.toString(64))\n\n//其他转十进制  \nconst x=&#39;110&#39;  \nconsole.log(parseInt(x, 2))  \nconsole.log(parseInt(x, 8))  \nconsole.log(parseInt(x, 16))  \n\n//其他转其他  \n//先用parseInt转成十进制再用toString转到目标进制  \nconsole.log(String.fromCharCode(parseInt(141, 8)))  \nconsole.log(parseInt(&#39;ff&#39;, 16).toString(2))</code></pre>"},function(e,n,t){var r=t(100),o=t(221),a=t(222),i=t(223),s=t(224),p="<h3 id=微信小程序原理>微信小程序原理</h3> <h4 id=渲染层和逻辑层>渲染层和逻辑层</h4> <blockquote> <p>由于渲染和逻辑不再同一个浏览器执行，一个在纯JS环境中，一个通过WebView渲染，因此小程序的运行环境分成渲染层和逻辑层，WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。</p> </blockquote> <p>小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型如图所示</p> <p><img src="+r(o)+' alt="alt 小程序渲染逻辑"></p> <h4 id=数据驱动视图变化>数据驱动视图变化</h4> <p>小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。</p> <p>通过setData把msg数据从“Hello World”变成“Goodbye”，产生的JS对象对应的节点就会发生变化，此时可以对比前后两个JS对象得到变化的部分，然后把这个差异应用到原来的Dom树上，从而达到更新UI的目的，这就是“数据驱动”的原理。</p> <p><img src='+r(a)+' alt="alt 小程序数据修改"> <img src='+r(i)+' alt="alt 数据驱动变化原理"></p> <h4 id=事件的处理>事件的处理</h4> <p>UI界面的程序需要和用户互动，例如用户可能会点击你界面上某个按钮，又或者长按某个区域，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户。由于WebView现在具备的功能只是进行渲染，因此对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给JavaScript进行处理。（和React的事件对象原理类似）</p> <p><img src='+r(s)+' alt="alt 小程序事件"></p> ';e.exports=p},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/wechat-mini-app-frame.png?8055616d05e364c2225592af848865dc"},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/wechat-mini-app-data-change.png?f508d4c5b044430d79556d1ef22b1d47"},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/wechat-mini-app-v-dom-diff.png?1e11794df1ca4660460bddfbdca2ad3a"},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/wechat-mini-app-action.png?e39f8bec67ac3586b60b19bacc7402bd"},function(e,n){e.exports="<h3 id=使用vw进行移动端自适应布局>使用vw进行移动端自适应布局</h3> <p>vw和vh是视口（viewport units）单位，何谓视口，就是根据你浏览器窗口的大小的单位，不受显示器分辨率的影响，是不是很神奇，这就代表了，我们不需要顾虑到现在那么多不同电脑有关分辨率的自适应问题。</p> <p>vw是可视窗口的宽度单位，和百分比有点一样，1vw = 可视窗口的宽度的百分之一。比如窗口宽度大小是1800px，那么1vw = 18px。和百分比不一样的是，vw始终相对于可视窗口的宽度，而百分比和其父元素的宽度有关</p> <pre><code>// 以750宽度的视觉稿；这样的话开发中的写法就可以直接拿视觉稿上的值 直接 / 100，方便开发\nbody {\n  font-size: calc(100vw / 7.5);\n}</code></pre>"},function(e,n){e.exports="<h3 id=historylisten>history.listen()</h3> <p>使用场景 后台系统 侧边栏 根据路由切换选中对应 router</p> "},function(e,n){e.exports="<h3 id=mac-chorme-跨域>mac chorme 跨域</h3> <p>open -n /Applications/Google\\ Chrome.app/ --args --disable-web-security --user-data-dir=/Users/YourUserName/Documents/MyChromeDevUserData </p> "},function(e,n){e.exports="<h3 id=小程序开发遇到的深坑>小程序开发遇到的深坑</h3> <h4 id=bindinput-开发者工具-取不到值>bindinput 开发者工具 取不到值</h4> <p>基础库 2.9.2 版本 以上 客户端 1.02.1907300 </p> <p>反思：应该第一时间寻求社区帮助！！！</p> <h4 id=setdata优美写法>setData优美写法</h4> <pre><code>// 数组 使用 [] 传 索引\nthis.setData({\n  [`activeData[${index}]`]: res,\n})\n\n// 对象 使用 x.x.x \nthis.setData({\n  [`activeData.${key}`]: res,\n})</code></pre>"},function(e,n){e.exports="<h3 id=数据更新和管理tips>数据更新和管理tips</h3> <h4 id=大量数组遍历>大量数组遍历</h4> <blockquote> <p>将数组转换成Map，生成对应的一个 索引 数组，后续操作对索引数组进行操作。根据返回的索引到Map中取数据</p> </blockquote> "},function(e,n){e.exports="<h2 id=贴一段hooks的antd列表页>贴一段hooks的antd列表页</h2> <blockquote> <p>缺点没注释</p> </blockquote> <pre><code>import React, {useState, useEffect} from &#39;react&#39;\nimport {useParams} from &#39;react-router-dom&#39;\nimport {Table, Input, Button, message} from &#39;antd&#39;\nimport io from &#39;./io&#39;\n\nconst SignUser = () =&gt; {\n  const {activityId} = useParams()\n  const [phone, setPhone] = useState()\n  const [userName, setUserName] = useState()\n  const [list, setList] = useState([])\n  const [currentPage, setCurrentPage] = useState(1)\n  const [total, setTotal] = useState(0)\n  const [pageSize, setPageSize] = useState(10)\n  const [query, setQuery] = useState(false)\n\n  const [fromSearch, setFromSearch] = useState(false)\n\n  useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n      try {\n        const res = await io.getUserList({\n          activityId,\n          phone,\n          userName,\n          currentPage,\n          pageSize,\n        })\n\n        if (fromSearch) {\n          setCurrentPage(1)\n          setFromSearch(false)\n        }\n\n        setTotal(res.count)\n        setList([...(res.data || [])])\n      } catch (e) {\n        message.error(e.message)\n      }\n    }\n\n    fetchData()\n  }, [query])\n\n  useEffect(() =&gt; {\n    setCurrentPage(1)\n  }, [pageSize])\n\n  const renderColumn = number =&gt; {\n    const width = `${(100 / number).toFixed(1)}%`\n\n    return [{\n      title: &#39;用户名&#39;,\n      dataIndex: &#39;userName&#39;,\n      width,\n    }, {\n      title: &#39;性别&#39;,\n      dataIndex: &#39;gender&#39;,\n      width,\n      render: value =&gt; value === 1 ? &#39;男士&#39; : &#39;女士&#39;,\n    }, {\n      title: &#39;手机&#39;,\n      dataIndex: &#39;phone&#39;,\n      width,\n    }, {\n      title: &#39;创建时间&#39;,\n      dataIndex: &#39;ctime&#39;,\n      width,\n    }]\n  }\n\n  return &lt;&gt;\n    &lt;div className=&quot;p24 bgf&quot;&gt;\n      &lt;div className=&quot;FBH FBJB&quot;&gt;\n        &lt;h2&gt;签到用户列表&lt;/h2&gt;\n\n        &lt;div className=&quot;FB1 FBH FBJE&quot;&gt;\n          &lt;Input className=&quot;mr8&quot; style={{width: 200, marginRight: 8}} placeholder=&quot;输入手机号&quot; onChange={e =&gt; setPhone(e.target.value)} /&gt;\n          &lt;Input className=&quot;mr8&quot; style={{width: 200, marginRight: 8}} placeholder=&quot;输入用户名&quot; onChange={e =&gt; setUserName(e.target.value)} /&gt;\n          &lt;Button \n            type=&quot;primary&quot; \n            onClick={() =&gt; {\n              setQuery(!query)\n              setFromSearch(true)\n            }}\n          &gt;搜索&lt;/Button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      &lt;Table \n         columns={renderColumn(8)}\n         dataSource={list}\n         onChange={(pagination, filters, sorter) =&gt; {\n           const {\n             pageSize,\n             current,\n             total,\n           } = pagination\n\n           setCurrentPage(current)\n           setPageSize(pageSize)\n           setTotal(total)\n\n           setQuery(!query)\n         }}\n         pagination={{\n           current: currentPage,\n           pageSize,\n           total,\n           showTotal: sum =&gt; `共${sum}条`,\n           showQuickJumper: true,\n           showSizeChanger: true,\n         }}\n      /&gt;\n    &lt;/div&gt;\n  &lt;/&gt;\n}\n\nexport default SignUser\n</code></pre>"},function(e,n){e.exports="<h3 id=reqiurecontext>reqiure.context</h3> <pre><code>const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)\nconst req = require.context(&#39;.&#39;, false, /\\.svg$/)\nrequireAll(req)</code></pre>"},function(e,n){e.exports="<h3 id=坑了2小时-勿忘common>坑了2小时 勿忘common</h3> <pre><code>function multiHtmlPlugin(entries) {\n  const pageNames = Object.keys(entries)\n  pageNames.map(name =&gt; {\n    plugins.push(\n      new HtmlWebpackPlugin({\n        filename: `${name}.html`,\n        template: &#39;./index.html&#39;,\n        chunks: [name, &#39;common&#39;],\n        minify: isProd\n          ? {\n            removeComments: true,\n            collapseWhitespace: true,\n            minifyCSS: true,\n          }\n          : true,\n      })\n    )\n  })\n}</code></pre>"},function(e,n){e.exports="<h3 id=设计思路-去中心化>设计思路-去中心化</h3> <ul> <li>逻辑向内聚合</li> <li>去耦合</li> <li>render层无逻辑</li> </ul> "},function(e,n){e.exports="<h3 id=利用requirecontext批量引入图片资源输出成组件>利用require.context批量引入图片资源输出成组件</h3> <h4 id=目录结构>目录结构</h4> <pre><code>├── folder --------------------  一个目录\n    ├── index.js  -------------  页面入口文件\n    ├── icons  ----------------  图片资源目录</code></pre><h4 id=indexjs>index.js</h4> <pre><code>// how to 新增一个icon \n// 将 png 图片复制到 icons目录即可\n// icon 文件名 命名 单一单词 或 驼峰写法 \n\n// 定义 组件对象\nconst mods = {}\n// 获取icons目录下所有png图片\nconst files = require.context(&#39;./icons&#39;, false, /\\.png$/)\n// 获取所有文件 相对路径 \n// eg: [&#39;./zip.png&#39;]\nconst reqPath = files.keys()\n\n// 循环目录结构 组件赋值\nreqPath.forEach(v =&gt; {\n  // 获取 文件名 根据后续需求修改即可\n  const name = v.replace(&#39;./&#39;, &#39;&#39;).split(&#39;.&#39;)[0]\n  // 组件名为 首字母大写的原文件名\n  const modName = name.replace(name[0], name[0].toUpperCase())\n  // 获取图片 \n  // 前面的是直接取文件 后面的是引入组件的写法\n  const img = files(v) || files(v).default \n\n  mods[modName] = ({ style }) =&gt; (\n    &lt;div style={{ width: 24, height: 24, ...(style || {}) }}&gt;\n      &lt;img style={{ width: &#39;100%&#39;, height: &#39;100%&#39; }} src={files(v)} /&gt;\n    &lt;/div&gt;\n  )\n})\n\nconsole.log(mods)\n\nmodule.exports = mods\n</code></pre><h4 id=已知问题-就是全部-png-都打进来了-包可能有点大>已知问题 就是全部 png 都打进来了 包可能有点大</h4> "},function(e,n){e.exports="<h3 id=利用suspense和lazy模块懒加载>利用Suspense和lazy模块懒加载</h3> <pre><code>import { Suspense, lazy } from &#39;react&#39;\n\nconst Home = lazy(() =&gt; import(&#39;@modules/file/home&#39;))\n\nconst Main = () =&gt; (\n  &lt;Suspense fallback=&#39;&#39;&gt;\n    &lt;Home /&gt;\n  &lt;/Suspense&gt;\n)\n\nexport default Main</code></pre>"},function(e,n){e.exports="<pre><code>import ReactDOM from &#39;react-dom&#39;\nimport { Modal, Alert } from &#39;antd&#39;\n\n// 备注：本来想传参对象的，但别人用了，改动的话工作量太大。先这样定义，看以后时机推动修改吧。\nconst errorEater = ({ code, message }, title, afterClose = () =&gt; {}) =&gt; {\n  const errorMap = new Map([\n    [&#39;0&#39;, &#39;default&#39;],\n    [&#39;1&#39;, &#39;info&#39;],\n    [&#39;2&#39;, &#39;warning&#39;],\n    [&#39;3&#39;, &#39;error&#39;]\n  ])\n\n  const errorType =\n    code &amp;&amp; errorMap.get(code[0]) ? errorMap.get(code[0]) : &#39;error&#39;\n\n  const afterCloseCallback = () =&gt; {\n    window.errorEaterStackLock = false\n\n    window.errorEaterMsgStack.shift()\n\n    afterClose({\n      type: errorType,\n      code,\n      message\n    })\n\n    if (window.errorEaterStack &amp;&amp; window.errorEaterStack.length &gt; 0) {\n      window.errorEaterStackLock = true\n      const next = window.errorEaterStack.shift()\n\n      next()\n    }\n  }\n\n  const renderError = () =&gt; {\n    Modal.error({\n      title: title || &#39;请求错误&#39;,\n      content: message || &#39;&#39;,\n      okText: &#39;知道了&#39;,\n      mask: true,\n      onOk: () =&gt; {\n        afterCloseCallback()\n      },\n      onCancel: () =&gt; {\n        afterCloseCallback()\n      }\n    })\n  }\n\n  const renderAlert = () =&gt; {\n    const wrap = document.createElement(&#39;div&#39;)\n\n    document.body.appendChild(wrap)\n\n    const maskStyle = {\n      position: &#39;fixed&#39;,\n      top: 0,\n      right: 0,\n      left: 0,\n      bottom: 0,\n      height: &#39;100%&#39;,\n      zIndex: 9999\n    }\n\n    const alertWrapStyle = {\n      position: &#39;absolute&#39;,\n      top: 50,\n      left: &#39;50%&#39;,\n      maxWidth: &#39;80%&#39;,\n      zIndex: 9999,\n      transform: &#39;translateX(-50%)&#39;,\n      width: 560\n    }\n\n    ReactDOM.render(\n      &lt;div\n        style={{ ...maskStyle }}\n        onClick={() =&gt; {\n          ReactDOM.unmountComponentAtNode(wrap)\n          document.body.removeChild(wrap)\n          afterCloseCallback()\n        }}\n      &gt;\n        &lt;div style={{ ...alertWrapStyle }}&gt;\n          &lt;Alert\n            message={message}\n            type={errorType}\n            afterClose={() =&gt; {\n              ReactDOM.unmountComponentAtNode(wrap)\n              document.body.removeChild(wrap)\n              afterCloseCallback()\n            }}\n            style={{\n              paddingRight: 50,\n              wordBreak: &#39;break-all&#39;,\n              textAlign: &#39;justify&#39;\n            }}\n            showIcon\n            closable\n          /&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;,\n      wrap\n    )\n  }\n\n  const judgeAction = action =&gt; {\n    if (window.errorEaterStack &amp;&amp; window.errorEaterStack.length &gt; 0) {\n      window.errorEaterStack.push(action)\n      window.errorEaterMsgStack.push(message)\n    } else if (window.errorEaterStackLock) {\n      window.errorEaterStack.push(action)\n      window.errorEaterMsgStack.push(message)\n    } else {\n      window.errorEaterStackLock = true\n      window.errorEaterStack = []\n      window.errorEaterMsgStack = [message]\n      action()\n    }\n  }\n\n  if (errorType === &#39;default&#39;) return null\n\n  if (errorType === &#39;error&#39;) {\n    if (\n      window.errorEaterMsgStack &amp;&amp;\n      window.errorEaterMsgStack.length &gt; 0 &amp;&amp;\n      window.errorEaterMsgStack.some(v =&gt; v === message)\n    )\n      return null\n\n    judgeAction(renderError)\n  }\n\n  if (errorType === &#39;info&#39; || errorType === &#39;warning&#39;) {\n    judgeAction(renderAlert)\n  }\n}\n\nexport default errorEater\n</code></pre>"},function(e,n){e.exports="<h3 id=接口定义返回结果原则>接口定义返回结果原则</h3> <ul> <li>所见及所得 尽量直接返回 展示的结果</li> <li>逻辑洁耦</li> </ul> "},function(e,n){e.exports="<h3 id=node-简易-本地静态服务>node 简易 本地静态服务</h3> <pre><code>const http = require(&#39;http&#39;)\nconst url = require(&#39;url&#39;)\nconst fs = require(&#39;fs&#39;)\nconst path = require(&#39;path&#39;)\n\nconst item = (name, parentPath) =&gt; {\n    const path = (parentPath = `${parentPath}/${name}`.slice(1))\n    return `&lt;div&gt;&lt;a href=&quot;${path}&quot;&gt;${name}&lt;/a&gt;&lt;/div&gt;`\n}\n\nconst list = (arr, parentPath) =&gt; {\n    return arr.map((name) =&gt; item(name, parentPath)).join(&#39;&#39;)\n}\n\nconst server = http.createServer((req, res) =&gt; {\n    let _path = url.parse(req.url).pathname //去掉search\n    let parentPath = _path\n    _path = path.join(__dirname, _path)\n    try {\n        // 拿到路径所对应的文件描述对象\n        const stats = fs.statSync(_path)\n        if (stats.isFile()) {\n            // 是文件，返回文件内容\n            const file = fs.readFileSync(_path)\n            res.end(file)\n        } else if (stats.isDirectory()) {\n            // 是目录，返回目录列表，让用户可以继续点击\n            const dirArray = fs.readdirSync(_path)\n            res.end(list(dirArray, parentPath))\n        } else {\n            res.end()\n        }\n    } catch (err) {\n        res.writeHead(404, &#39;Not Found&#39;)\n        res.end()\n    }\n})\n\nconst port = 9000\nconst hostname = &#39;127.0.0.1&#39;\nserver.listen(port, hostname, () =&gt; {\n    console.log(`server is running on http://${hostname}:${port}`)\n})</code></pre>"},function(e,n){e.exports="<h3 id=antd-script-标签引入-定制样式>antd script 标签引入 定制样式</h3> <blockquote> <p>定制样式 需要 less 配合 theme.json ,antd 在 devDependencies 中维护</p> </blockquote> <h4 id=入口页引入-less>入口页引入 less</h4> <pre><code>import &#39;antd/dist/less&#39;</code></pre><h4 id=webpackconfigjs-引入主题配置文件-配置loader>webpack.config.js 引入主题配置文件 配置loader</h4> <pre><code>const theme = require(&#39;./theme.json&#39;)\n\n...\n\nmodule: {\n  ...\n  rules: [\n    ...\n    {\n      test: /\\.(le|c)ss$/,\n      use: [\n        isDEV ? &#39;style-loader&#39; : MiniCssExtractPlugin.loader,\n        &#39;css-loader&#39;, \n        { \n          loader: &#39;postcss-loader&#39;,\n          options: {\n            plugins: loader =&gt; [\n              require(&#39;autoprefixer&#39;)(), // CSS浏览器兼容 需要package.json 添加 对应的 browserslist,也有其他方式，自行搜索\n            ]\n          }\n        },\n        `less-loader?{&quot;sourceMap&quot;:true, &quot;modifyVars&quot;:${JSON.stringify(theme)}, &quot;javascriptEnabled&quot;: true}`,\n      ], // 注意排列顺序，执行顺序与排列顺序相反\n    },\n    ...\n  ],\n  ...\n}\n...</code></pre>"},function(e,n){e.exports="<h3 id=objectdefinepropertyobject-propertyname-descriptor>Object.defineProperty(object, propertyname, descriptor)</h3> <p>object 必需。 要在其上添加或修改属性的对象。 这可能是一个本机 JavaScript对象（即用户定义的对象或内置对象）或 DOM 对象。 propertyname 必需。 一个包含属性名称的字符串。 descriptor 必需。 属性描述符。 它可以针对数据属性或访问器属性。</p> <h4 id=descriptor>descriptor</h4> <p>【get】一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。 【set】 一旦目标对象设置该属性，就会调用这个方法。默认为 undefined</p> <p>【value】 属性的值，默认为 undefined。 【writable】 该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p> <p>【configurable]】如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。 。</p> <p>【enumerable】 是否能在for-in循环中遍历出来或在Object.keys中列举出来。对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。 注意 在调用Object.defineProperty()方法时，如果不指定， configurable， enumerable， writable特性的默认值都是false,这跟之前所 说的对于像前面例子中直接在对象上定义的属性，这个特性默认值为为 true。并不冲突，如下代码所示：</p> <pre><code>//调用Object.defineProperty()方法时，如果不指定\nvar someOne = { };\nsomeOne.name = &#39;coverguo&#39;;\nconsole.log(Object.getOwnPropertyDescriptor(someOne, &#39;name&#39;));\n//输出 Object {value: &quot;coverguo&quot;, writable: true, enumerable: true, configurable: true}\n\n//直接在对象上定义的属性，这个特性默认值为为 true\nvar otherOne = {};\nObject.defineProperty(otherOne, &quot;name&quot;, {\n    value:&quot;coverguo&quot; \n});  \nconsole.log(Object.getOwnPropertyDescriptor(otherOne, &#39;name&#39;));\n//输出 Object {value: &quot;coverguo&quot;, writable: false, enumerable: false, configurable: false}</code></pre>"},function(e,n){e.exports="<h3 id=react-router-switch存在的意义>react-router switch存在的意义</h3> <p>有<switch>标签，则其中的<route>在路径相同的情况下，只匹配第一个，这个可以避免重复匹配； 无<switch>标签，则其中的<route>在路径相同的情况下全都会匹配。更严重的是，还会匹配上级路径的；</route></switch></route></switch></p> "},function(e,n){e.exports='<h3 id="null-和-undefined-的区别">null 和 undefined 的区别</h3> <p>null 表示 不存在的对象 undefined 表示 不存在的值</p> '},function(e,n){e.exports="<h3 id=写一套serverless>写一套serverless</h3> "},function(e,n,t){var r=t(100),o=t(245),a=t(246),i="<p>如果数据赋值这一动作委托给某函数处理，我们可以借助 AOP 编程思想，在该函数的执行过程中，添加一些附加操作，如上报变更信息、启用回调函数、或者触发指定事件等。正因为如此，Vue 才得以通过 Object.defineProperty 实现双向数据绑定；React 才得以通过 setState 实现组件重绘。mobx 融合了两种处理手法。首先，mobx 基于原始数据构建 observable 实例，在 observable 实例方法变更数据的过程中，将执行 interceptor, listener, reportChanged 等附加操作，这一机制如同 React 内建的 setState 方法在变更组件状态的同时，还能驱动组件重绘。其次，mobx 通过 Object.defineProperty 将原始数据（对象形式）的赋值、取值动作委托给 observable 实例方法去处理，使得原始数据的赋值动作转变成响应式的、取值动作又能获得原始数据内容，这一过程同 Vue 那样使用了 Object.defineProperty 方法。</p> <h3 id=vue>Vue</h3> <p><img src="+r(o)+' alt="alt Vue 数据劫持"></p> <p>vue 是利用的是 Object.defineProperty() 对Object的getter和setter方法修改来对数据进行劫持。 并在数据传递变更的时候封装了一层中转站，即我们看到的 Dep 和 Watcher 两个类</p> <h3 id=mobx>Mobx</h3> <p>mobx 基于原始数据构建 observable 实例。</p> <p>mobx 能将如下几种数据类型转变为 observable 实例：ObservableValue 实例作为代理，能将基本数据类型的赋值动作转变成响应式的；ObservableObjectAdministration 实例能处理对象；ObservableArrayAdministration 实例能处理数组；ObservableMap 实例能处理 map 数据结构。</p> <p><img src='+r(a)+' alt="alt mobx-对象包装"></p> ';e.exports=i},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/vue-data-catch.png?607338b18c1e9c118bfae2ad7f0c553d"},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/mobx-object-wrap.jpg?ea28ae696fdf3a5612ffc2ff0e9f49ad"},function(e,n){e.exports="<h3 id=getsearchparam>getSearchParam</h3> <pre><code>export const getSearchParam = search =&gt; search\n  .replace(&#39;?&#39;, &#39;&#39;)\n  .split(&#39;&amp;&#39;)\n  .reduce((pre, v) =&gt; {\n    const arr = v.split(&#39;=&#39;)\n    // 处理中文\n    pre[arr[0]] = decodeURI(arr[1])\n\n    return pre\n  }, {})</code></pre>"},function(e,n){e.exports="<p>给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。</p> <p>你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;= 1），这样一轮之后你将得到 k*k 个积分。</p> <p>当你将所有盒子都去掉之后，求你能获得的最大积分和。 示例 1： 输入: [1, 3, 2, 2, 2, 3, 4, 3, 1] 输出: 23 解释: [1, 3, 2, 2, 2, 3, 4, 3, 1] ----&gt; [1, 3, 3, 4, 3, 1] (3<em>3=9 分) ----&gt; [1, 3, 3, 3, 1] (1</em>1=1 分) ----&gt; [1, 1] (3<em>3=9 分) ----&gt; [] (2</em>2=4 分) 提示：盒子的总数 n 不会超过 100。</p> <pre><code>// reduce 处理 数组 每一项，将 一个数据 拆分为 n 个 段\n// 每一段 存储 value length index\n// 拆分时 分为两个数组 \n// 一个数组 按索引 存储 \n// 一个数据 按长度 存储\n\n// 第一轮 要判断所有 长度不为一 并且 左右邻居相等 的 项 并清除\n// 第二轮 要判断所有 长度不为一 并且 左右邻居不相等 的 项 并清除\n\nconst source = [1, 3, 2, 2, 2, 3, 4, 3, 1]\n\nconst formated = source.reduce((pre, value, index, array) =&gt; {\n    // 第一轮第一个\n    if (index === 0) {\n        pre.push({\n            value: value,\n            length: 1,\n            index: pre.length,\n        })\n    } else {\n        // 后面 的 和上一个相等\n        if (value === array[index - 1]) {\n            pre[0].length = pre[0].length + 1\n        } else {\n            pre.push({\n                value,\n                length: 1,\n                index: pre.length,\n            })\n        }\n    }\n\n    return pre\n}, [])\n\nconst sortByLengthArray = formated.sort((a, b) =&gt; {return a.length - b.length})\n\n\nconst getMaxPoint = () =&gt; {\n     const \n}\n</code></pre>"},function(e,n){e.exports="<h3 id=前端缓存策略>前端缓存策略</h3> <p>缓存的类型</p> <p>浏览器有如下常见的几个字段：</p> <p>expires: 设置缓存过期的时间 private: 客户端可以缓存 public: 客户端和代理服务器都可缓存 max-age=xxx: 缓存的内容将在 xxx 秒后失效 no-cache: 需要使用对比缓存来验证缓存数据 no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发 last-modified: 内容上次被修改的时间 Etag: 文件的特殊标识</p> <blockquote> <p>缓存方法可以分为强制缓存与协商缓存。</p> </blockquote> <h4 id=强制缓存>强制缓存</h4> <blockquote> <p>从字面理解，强制缓存的方式简单粗暴，给<code>cache</code>设置了<code>过期时间</code>，超过这个时间之后cache过期需要重新请求。上述字段中的<code>expires</code>与<code>cache-control中的max-age</code>都属于强制缓存</p> </blockquote> <blockquote> <p>强制缓存优先级高于协商缓存</p> </blockquote> <h5 id=expires>expires</h5> <blockquote> <p>expires给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求。</p> </blockquote> <p><code>Expires: Fri, 04 Jan 2019 12:00:00 GMT</code></p> <p>这个方法简单直接，直接设定一个绝对的时间 (当前时间+缓存时间)。但是也存在隐患，例如浏览器当前时间是可以进行更改的，更改之后expires设置的绝对时间相对不准确，cache可能会出现长久不过期或者很快就过期的情况。</p> <h5 id=cache-control-max-age>cache-control: max-age</h5> <blockquote> <p>为了解决expires存在的问题，Http1.1版本中提出了cache-control: max-age，该字段与expires的缓存思路相同，都是设置了一个过期时间，不同的是max-age设置的是相对缓存时间开始往后多久，因此不存在受日期不准确情况的影响。</p> </blockquote> <p>但是强制缓存存在一个问题，该缓存方式优先级高，如果在过期时间内缓存的资源在服务器上更新了，客服端不能及时获取最新的资源。</p> <h4 id=协商缓存>协商缓存</h4> <p>协商缓存解决了无法及时获取更新资源的问题。以下两组字段，都可以对资源做标识，由服务器做分析，如果未进行更新，那返回304状态码，从缓存中读取资源，否则重新请求资源</p> <h5 id=last-modify>last-modify</h5> <blockquote> <p>last-modify告知了客户端上次修改该资源的时间，</p> </blockquote> <p><code>Last-Modified: Wed, 02 Jan 2019 03:06:03 GMT</code></p> <p>浏览器将这个值记录在<code>if-modify-since</code>中(浏览器自动记录了该字段信息)，下一次请求相同资源时，与服务器返回的<code>last-modify</code>进行比对，如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。</p> <p>last-modify以秒为单位进行更新，如果小于该单位高频进行更新的话，不适合采用该方法。</p> <h5 id=etag>ETag</h5> <blockquote> <p>ETag是对资源的特殊标识</p> </blockquote> <p><code>Etag: W/&quot;e563df87b65299122770e0a84ada084f&quot;</code></p> <p>请求该资源成功之后，将返回的ETag存入if-none-match字段中(浏览器自动记录了该字段信息)，同样在请求资源时传递给服务器，服务器查询该编码对应的资源有无更新，无更新返回304状态，更新返回200并重新请求。</p> "},function(e,n){e.exports="<h3 id=gitlab-cliymlmd>gitlab-cli.yml.md</h3> <pre><code>image: docker:git\nservices:\n  - docker:dind\n\nvariables:\n  DOCKER_DRIVER: overlay\n  PROJECT_NAME: demo\n  VERSION: ${CI_COMMIT_TAG}\n\ncache:\n  paths:\n    - tgz\n\nstages:\n  - build\n  - package\n\nbuild:\n  image: image_url\n  stage: build\n  script: \n    - rm -rf tgz/*\n    - npm install\n    - sh ./deploy.sh ${VERSION}\n    - cd tgz\n    - ls\n  only:\n    - tags\n\nupload:\n  image: example_file_path\n  stage: package\n  cache:\n    paths:\n      - tgz\n  dependencies:\n    - build\n  script:\n    - ls\n    - mc mb dev/frontend/${PROJECT_NAME}/${CI_COMMIT_TAG}/\n    - mc cp tgz/*${VERSION}.tgz dev/frontend/${PROJECT_NAME}/${CI_COMMIT_TAG}/\n    - cd tgz \n    - ls\n\n  only:\n    - tags\n</code></pre>"},function(e,n){e.exports="<h3 id=shell>shell</h3> <pre><code>#!/bin/bash\n# 打 开发包\n# eg sh ./deploy.sh\n# 打 提测包\n# eg: sh ./deploy.sh tag_name\n\n# 打包命令\nnpm run build\n# 复制 vendor 到 打包后的目录\ncp -r ./vendors ./dist\n\n# 获取当前时间戳\nnow=`date +%Y%m%d%H%M`\n\n# 判断是否有tag_name\nif [ x$1 != x ]\nthen\n    #...有参数\n    package_name=&quot;demo_v$1.tgz&quot;\nelse\n    #...没有参数\n    package_name=&quot;demo_$now.tgz&quot;\nfi\n\ntar zcvf $package_name ./dist\nmkdir tgz\nmv $package_name ./tgz</code></pre>"},function(e,n){e.exports="<h3 id=钉钉模块的插件化开发思路-或者-小程序的思路>钉钉模块的插件化开发思路 或者 小程序的思路</h3> <p>jsBridge 开放 调用底层 的能力。 首次 初始化入口。 每次使用后应该会有缓存机制，达到一定大小后自动回收，或设置过期时间。 点开应用就是 一个js 应用 （| 小程序）</p> "},function(e,n){e.exports="<h3 id=一个图片全屏预览组件>一个图片全屏预览组件</h3> <pre><code>import { useState } from &#39;react&#39;\nimport { Button } from &#39;antd&#39;\n\nconst FullscreenPreviewImage = ({src}) =&gt; {\n    const [visible, setVisible] = useState(false)\n\n    return (\n        [\n            &lt;Button shape=&quot;circle&quot; icon=&quot;fullscreen&quot; size=&quot;large&quot; onClick={() =&gt; setVisible(true)} /&gt;,\n            visible &amp;&amp; &lt;div \n                style={{\n                    position: &quot;fixed&quot;,\n                    top: 0,\n                    left: 0,\n                    right: 0,\n                    bottom: 0,\n                    overflowY: &#39;auto&#39;,\n                    zIndex: 1000,\n                    backgroundColor: &#39;rgba(0,0,0, .6)&#39;,\n\n                }}\n                className=&quot;box-align&quot;\n                onClick={() =&gt; setVisible(false)}\n            &gt;\n                &lt;img src={src} style={{cursor: &#39;zoom-out&#39;}} /&gt;\n            &lt;/div&gt;\n        ]\n    )\n}\n\nexport default FullscreenPreviewImage\n\n\n// .box-align\n.box-align {\n    display: -webkit-box;\n    -webkit-box-align: center;\n    -webkit-box-pack: center;\n    display: -moz-box;\n    -moz-box-align: center;\n    -moz-box-pack: center;\n    display: -o-box;\n    -o-box-align: center;\n    -o-box-pack: center;\n    display: -ms-box;\n    -ms-box-align: center;\n    -ms-box-pack: center;\n    display: box;\n    box-align: center;\n    box-pack: center;\n}</code></pre>"},function(e,n,t){var r="<h3 id=试试一个文本标注的本地场景>试试一个文本标注的本地场景</h3> <p><img src="+t(100)(t(255))+' alt="alt 中文"></p> <p><a href=https://webpack.js.org/guides/中文>webpack 英文文档 指南栏</a> </p> ';e.exports=r},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/event-loop-中文.png?4118d4c68c99261a62da7dc7348d0fce"},function(e,n){e.exports="<h3 id=urlcreateobjecturl>URL.createObjectURL()</h3> <p><a href=https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL>MDN URL.createObjectURL()</a></p> <h4 id=场景>场景</h4> <p>前端手动创建文件并触发浏览器下载</p> <p>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据</p> <pre><code>const data = {}\nconst url = window.URL.createObjectURL(new Blob(data));\nconst link = document.createElement(&#39;a&#39;);\nlink.href = url;\nlink.setAttribute(&#39;download&#39;, &#39;file.&#39; + this.format); // or any other extension\ndocument.body.appendChild(link);\nlink.click();\ndocument.body.removeChild(link);</code></pre>"},function(e,n){e.exports="<pre><code>class BasicPlugin{\n  // 在构造函数中获取用户给该插件传入的配置\n  constructor(options){\n  }\n\n  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象\n  apply(compiler){\n    compiler.plugin(&#39;compilation&#39;,function(compilation) {\n    })\n  }\n}\n// 导出 Plugin\nmodule.exports = BasicPlugin;\n</code></pre><p>Webpack启动后，在读取配置的过程中会先执行new BasicPlugin(options)初始化一个BasicPlugin获得其实例。 在初始化compiler对象后，再调用basicPlugin.apply(compiler)给插件实例传入compiler对象。 插件实例在获取到compiler对象后，就可以通过compiler.plugin(事件名称, 回调函数)监听到Webpack广播出来的事件。 并且可以通过compiler对象去操作Webpack。</p> <p>Tapable 基于事件流 </p> <h3 id=webpack构建流程（原理）>webpack构建流程（原理）</h3> <p>从启动构建到输出结果一系列过程：</p> <p>（1）初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。</p> <p>（2）开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。</p> <p>（3）确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。</p> <p>（4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</p> <p>（5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。</p> <p>（6）输出完成：输出所有的chunk到文件系统。</p> <p>注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如UglifyPlugin会在loader转换递归完对结果使用UglifyJs压缩覆盖之前的结果。</p> "},function(e,n){e.exports="<h3 id=img>img</h3> <pre><code> /&lt;img.*?src=&quot;(.*?)&quot;.*?\\/?&gt;/ig</code></pre><h3 id=a>a</h3> <pre><code>/&lt;a.*?href=&quot;(.*?)&quot;.*?\\/?&gt;/ig</code></pre><h3 id=场景>场景</h3> <pre><code>const str = &#39;&lt;img src=&quot;../markdown-images/vue-data-catch.png&quot; alt=&quot;alt Vue 数据劫持&quot;&gt; &lt;a href=&quot;https://www.baidu.com&quot; /&gt;&#39;\n\n// 上面的2合1\nconst pattern = /&lt;[img|a].*?[src|href]=&quot;(.*?)&quot;.*?\\/?&gt;/ig\n\nconst matchArr = []\nconst captureArr = []\n\nconst result = marked(markdown).replace(pattern, function (match, capture) {\n    // match 为 整个 标签\n    // capture 为 () 内 匹配的值\n    matchArr.push(match)\n    captureArr.push(capture)\n    return decodeURI(match)\n}) \n\nconsole.log(matchArr)\nconsole.log(captureArr)\n// matchArr \n// [&#39;&lt;img src=&quot;../markdown-images/vue-data-catch.png&quot; alt=&quot;alt Vue 数据劫持&quot;&gt;&#39;, &#39;&lt;a href=&quot;https://www.baidu.com&quot;&#39;]\n\n// captureArr\n// [&#39;../markdown-images/vue-data-catch.png&#39;, &#39;https://www.baidu.com&#39;]</code></pre><h3 id=处理-svg-的一个-正则-场景>处理 svg 的一个 正则 场景</h3> <pre><code>const fs = require(&#39;fs&#39;)\n\nfs.readFile(&#39;./test.svg&#39;, &#39;utf8&#39;, (err, data) =&gt; {\n    // 删除 style 和 title 标签\n    data = data.replace(/&lt;style&gt;(.*?)&lt;\\/style&gt;|&lt;title&gt;(.*?)&lt;\\/title&gt;/g, &#39;&#39;)\n\n    // 删除 id 和 data-name 属性\n    data = data.replace(/&lt;svg.*?(id=&quot;.*?&quot;) (data-name=&quot;.*?&quot;).*?&gt;/g, function (match, idCapture, dataNamecapture) {\n        // match 为 整个 标签\n        // capture 为 () 内 匹配的值\n        // matchArr.push(match)\n        // captureArr.push(capture)\n        // return decodeURI(match)\n        return match.replace(idCapture, &#39;&#39;).replace(dataNamecapture, &#39;&#39;)\n    })\n\n    // 删除 空的 defs\n    data = data.replace(/&lt;defs&gt;&lt;\\/defs&gt;/g, &#39;&#39;)\n\n    // 删除 class 属性\n    data = data.replace(/class=&quot;(.*?)&quot;/g, &#39;&#39;)\n\n    if (err) reject(err)\n\n    console.log(data)\n})</code></pre>"},function(e,n){e.exports="<h3 id=npm-包>npm 包</h3> <h4 id=发布>发布</h4> <p><code>npm publish</code></p> <h4 id=设置npm-源>设置npm 源</h4> <p><code>npm config set registry https://registry.npmjs.org/</code></p> <h4 id=npm-一些-报错>npm 一些 报错</h4> <h5 id=未登陆>未登陆</h5> <pre><code>npm ERR! code ENEEDAUTH\nnpm ERR! need auth auth required for publishing\nnpm ERR! need auth You need to authorize this machine using `npm adduser`</code></pre><h5 id=非npm源>非npm源</h5> <pre><code>npm ERR! publish Failed PUT 403\nnpm ERR! code E403\nnpm ERR! no_perms Private mode enable, only admin can publish this module:...</code></pre><p>改回npm源</p> <pre><code>npm config set registry=http://registry.npmjs.org</code></pre><h5 id=名称已被用>名称已被用</h5> <pre><code>npm ERR! publish Failed PUT 403\nnpm ERR! code E403\nnpm ERR! You do not have permission to publish &quot;mini-cli&quot;. Are you logged in as the correct user? : XXX</code></pre><h5 id=版本没改>版本没改</h5> <pre><code>npm ERR! publish Failed PUT 403\nnpm ERR! code E403\nnpm ERR! You cannot publish over the previously published versions: 0.0.X. : XXX</code></pre><h5 id=未认证邮箱>未认证邮箱</h5> <pre><code>npm ERR! publish Failed PUT 403\nnpm ERR! code E403\nnpm ERR! You must verify your email before publishing a new package</code></pre><h5 id=发布私有包报错>发布私有包报错</h5> <pre><code>npm ERR! code E402\nnpm ERR! 402 Payment Required - PUT https://registry.npmjs.org/@yunlong.syl%2fmarkdown-loader - You must sign up for private packages</code></pre><blockquote> <p>npm publish --access=public</p> </blockquote> <h4 id=npm-link>npm link</h4> <p>本地调试方法</p> <pre><code>在B包里：\nnpm link // 相当于npm install B -g\n在A包里：\nnpm link B // 代码无需修改，package.json中引用B的包会自动指向本地B的打包文件\nA包发布测试环境测试</code></pre>"},function(e,n){e.exports="<h3 id=react-router-switch标签存在的意义>react-router switch标签存在的意义</h3> <p>有<switch>标签，则其中的<route>在路径相同的情况下，只匹配第一个，这个可以避免重复匹配； 无<switch>标签，则其中的<route>在路径相同的情况下全都会匹配。更严重的是，还会匹配上级路径的；</route></switch></route></switch></p> "},function(e,n){e.exports="<h3 id=antd-form-validatefields-不执行的一个原因>antd form validateFields 不执行的一个原因</h3> <p>在使用antd form组件的的validateFields或者validateFieldsAndScroll方法时如果它没有进入方法而是直接跳过了方法，那不妨看看自定义验证方法validator代码块里是否有某一条分支没有执行 callback 函数。官方规定：自定义校验 callback 必须被调用。</p> "},function(e,n){e.exports="<h3 id=面试时，问自己做的好的点>面试时，问自己做的好的点</h3> <p>旧的 项目 有一个 BFF node 层，导致前端项目 部署 运维 成本加大 现在 云开发 概念 就是 前端 serverless 的 一种产品化模式，前端开发人员更专注于业务及用户体验</p> <p>项目中：</p> <p>天机项目 中 前端项目架构上的优化，公共的util更新</p> <p>前端业务逻辑上的确认及优化 比如header头，因为本来项目没有 上级 项目的概念，添加项目概念后，整个代码架构 需要调整</p> <p>和 后端同学 确认发布流程</p> <p>编写 shell 脚本 方便 打包 发布</p> <p>gitlab-ci 脚本 编写</p> <p>比如服务管理模块 对api 的一些限制 参数 确定的方案 由后端 来控制，这样对于 不同的 交付 场景，这种个性化的需求 修改起来也比较容易</p> <p>小程序开发过程中 也 沉淀了 初始化的项目 模版 以及 获取用户信息的弹窗 和一些 表单组件，以为用antd 比较多，所以用antd 的组件思维 写了一些</p> <p>技术上：</p> <p>最新的hooks</p> <p>小程序 云开发 serverless 的 概念 开发人员更专注于 开发业务 </p> <p>pdf 预览组件 对接 pdfjs</p> <p>node</p> <p>可以说的点</p> <p> 写了 一个 npm 包 用来初始化项目 还有一个 loader 是因为 自己写git page 时 用到了 markdown-loader 但是 markdown 的 地址有中文的话 会被 转编码。当时 </p> <p> 自己写的gitpage 因为 markdown-loader 解析 url 时 会把中文 encodeURI 看过 marked 源码 发现 是 marked 在处理 链接时 编码，因为是世界通用的一种标准 把对应的 markdown 语法通过正则匹配 处理成 a 和 img 标签 我这里的处理就是 在 loader 获取到 marked 第三方工具 处理后的 dom 字符串 中 用正则匹配 到 a 标签 和 img 标签的 src 级 href 属性 的值 decodeURI 处理</p> <p>hooks 的场景 提取公用的 表格 搜索 弹窗 的 业务逻辑 整合成 自定义的hook </p> <p> 函数组件 内部 有 类似 class 写法的 变量 。 使用 useRef 的 特性。可以函数内部 创建一个 类似 store 概念的 将 页面里面用到的 值存在 ref 中 因为 useRef 是 对象 我一般的写法 是 结构 获取到 current 并且 将 current 属性 用 定义 一个 store 的别名 因为 我们使用 订阅发布 的 模式 进行 数据 传输</p> <p> 我有个表格列表页。有 一个 名称搜索的 功能。我的写法 的话。 定义两个state list 和 tableLoading 定义一个ref 里面 定一个 param 字段 保存 搜索条件 一般有 current 当前页 和 pageSize 每页大小 那名称 搜索条件 就是 name 字段</p> <p> 因为设计的时候模块 根据 ui 分模块 逻辑尽可能独立。那么 搜索框 和 table 是写在两个组件里面的。 这样的话 输入框内容 更新时 diff 不会触发 table 的 diff。 只有在出发搜索动作的时候 才触发 table 数据请求 更新table</p> <p>hooks 的小问题</p> <p> 所有定义的 useEffect 初始化的时候都会被运行一次 有些 时候 会 导致 多余请求 和 神奇的 变量 值被修改了 。 我碰到的就是 一个 搜索 的场景 。 我定一个 effect 监听 搜索条件 更新时 同步到其他组件。触发请求操作 因为 本来有个逻辑 搜索内容为空时 不触发搜索。 初始化的时候 所有条件都是空的。但是发了请求。很纳闷当时。 发现是 初始化的 时候 触发了 事件 的 emit</p> <p> useEffect 不允许 传入 async 函数 因为 useEffect 的 函数 不允许 有 返回 而 async 函数 返回一个 promise 对象</p> "},function(e,n){e.exports="<h3 id=async-await>async await</h3> <p>总的来说，async 是Generator函数的语法糖，并对Generator函数进行了改进。</p> <p>根据 MDN 定义，async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。可以说async 是Generator函数的语法糖，并对Generator函数进行了改进。</p> <h4 id=async-函数返回的是一个promise-对象>async 函数返回的是一个promise 对象</h4> <p>async 函数内部的实现原理。</p> <p>如果async 函数中有返回一个值，当调用该函数时，内部会调用Promise.resolve() 方法把它转化成一个promise 对象作为返回， 函数内部抛出错误呢？ 那么就会调用Promise.reject() 返回一个promise 对象</p> <h4 id=await-关键字>await 关键字</h4> <p>await是等待的意思，那么它等待什么呢，它后面跟着什么呢？其实它后面可以放任何表达式，不过我们更多的是放一个返回promise 对象的表达式。 注意await 关键字只能放到async 函数里面</p> "},function(e,n){e.exports="<h3 id=react-pdf>react-pdf</h3> <blockquote> <p>直接托管 pdfjs 静态服务 完美，不自己瞎玩了</p> </blockquote> "},function(e,n){e.exports="<h3 id=react-高阶组件>react 高阶组件</h3> <p>高阶组件（HOC）是React开发中的特有名词，一个函数返回一个React组件，指的就是一个React组包裹着另一个React组件。可以理解为一个生产React组件的工厂。</p> <p>有两种类型的HOC：</p> <p>实现高阶组件的方法有如下两种。</p> <p>属性代理(props proxy)。属性组件通过被包裹的 React 组件来操作 props。 反向代理(inheritance inversion)。高阶组件继承于被包裹的 React 组件。</p> <h4 id=props-proxy>Props Proxy</h4> <p>在pp中，我们可以对WrappedComponent进行以下操作：</p> <p>操作props（增删改） 通过refs访问到组件实例 提取state 用其他元素包裹WrappedComponent</p> <pre><code>const MyContainer = (WrappedComponent) =&gt; {\n    return class extends Component {\n        render() {\n            return (\n                &lt;WrappedComponent\n                    {...props}\n                /&gt;\n            )\n        }\n    }\n}\n\nexport default MyContainer;</code></pre><p>在 render 方法中返回传入 WrappedComponent 的 React 组件。这样就可以通过高阶组件来传递 props，这种方法即为属性代理。</p> <h4 id=inheritance-inversion>Inheritance Inversion</h4> <p>我们可以使用Inheritance Inversion实现以下功能：</p> <p>渲染劫持（Render Highjacking） 操作state</p> <pre><code>function iiHOC(WrappedComponent) {\n  return class Enhancer extends WrappedComponent {\n    render() {\n      return super.render()\n    }\n  }\n}</code></pre><h5 id=条件渲染>条件渲染</h5> <pre><code>function iiHOC(WrappedComponent) {\n  return class Enhancer extends WrappedComponent {\n    render() {\n      if (!this.props.loading) {\n        return super.render()\n      } else {\n        return &lt;div&gt;loading&lt;/div&gt;    \n      }\n    }\n  }\n}</code></pre><h5 id=修改渲染>修改渲染</h5> <pre><code>function iiHOC(WrappedComponent) {\n  return class Enhancer extends WrappedComponent {\n    render() {\n      const elementsTree = super.render()\n      let newProps = {};\n      if (elementsTree &amp;&amp; elementsTree.type === &#39;input&#39;) {\n        newProps = {value: &#39;may the force be with you&#39;}\n      }\n      const props = Object.assign({}, elementsTree.props, newProps)\n      const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children)\n      return newElementsTree\n    }\n  }\n}</code></pre><h4 id=高阶组件参数>高阶组件参数</h4> <pre><code>function HOCFactoryFactory(...params) {\n    return function HOCFactory(WrappedComponent) {\n        return class HOC extends Component {\n            render() {\n                return (\n                    &lt;WrappedComponent \n                        {...this.props}\n                    /&gt;\n                );\n            }\n        }\n    }\n}</code></pre><p>eg: Form.create()(Component)</p> "},function(e,n){e.exports="<h4 id=一个日志组件>一个日志组件</h4> <pre><code>import { Component } from &#39;react&#39;\nimport { Modal, Button, Icon } from &#39;antd&#39;\nimport ErrorEater from &#39;@dtwave/error-eater&#39;\n\nexport default class Log extends Component {\n    timer = undefined\n    logView = undefined\n\n    defaultParam = {}\n    getData = undefined\n\n    state = {\n        visible: false,\n        finished: false,\n\n        startLine: 1,\n        limitSize: 10240,\n\n        logs: [],\n    }\n\n    componentDidMount() {\n        emitter.addListener(&#39;log_show&#39;, (getData, defaultParam) =&gt; {\n            console.log(getData, defaultParam)\n            this.setState({\n                visible: true,\n            })\n            this.defaultParam = defaultParam\n            this.getData = getData\n\n            this.getLog(defaultParam)\n        })\n    }\n\n    componentWillUnmount() {\n        // 组件销毁之前，把监听事件销毁\n        // 这是为了避免过度使用emitter，造成资源浪费，也容易造成重复触发\n        emitter.removeAllListeners()\n    }\n\n    onClose = () =&gt; {\n        this.setState({\n            visible: false,\n            logs: [],\n            startLine: 1,\n            finished: false\n        })\n\n        clearTimeout(this.timer)\n    }\n\n    getLog = async () =&gt; {\n        const {\n            state: { startLine, limitSize, logs }\n        } = this\n\n        try {\n            const res = await this.getData({\n                ...this.defaultParam,\n                startLine,\n                limitSize,\n            })\n\n            let _startLine = startLine + limitSize\n\n            const endFlag = &#39;END-EOF-END-EOF&#39;\n\n            const finished = res.data.endsWith(endFlag)\n\n            if (finished) res.data = res.data.slice(0, - endFlag.length)\n\n            // 判断 如果 获取到的日志 长度 不为 10240 并且 不 finished\n\n            if (!finished &amp;&amp; res.data.length &lt;= limitSize) {\n                _startLine = res.startLine + res.data.length\n            }\n\n            console.log(_startLine)\n\n            this.setState({\n                finished,\n                startLine: _startLine,\n                logs: logs.concat((res.data || &#39;&#39;).split(&#39;\\n&#39;))\n            })\n\n            if (!finished) {\n                this.timer = setTimeout(() =&gt; {\n                    this.getLog()\n                }, 1000)\n            } else {\n                clearTimeout(this.timer)\n            }\n        } catch (e) {\n            ErrorEater(e)\n        }\n    }\n\n    render() {\n        const t = this\n        const { visible, finished, logs} = t.state\n\n        return (\n            &lt;Modal\n                visible={visible}\n                title=&quot;查看日志&quot;\n                onCancel={this.onClose}\n                width={840}\n                footer={[\n                    &lt;Button\n                        key=&quot;back&quot;\n                        onClick={this.onClose}\n                        type=&quot;primary&quot;\n                    &gt;\n                        关闭\n                    &lt;/Button&gt;\n                ]}\n                destroyOnClose\n            &gt;\n                &lt;div\n                    style={{ height: 400, overflow: &#39;auto&#39;, margin: 0 }}\n                    ref={e =&gt; (this.logView = e)}\n                &gt;\n                    {\n                        logs.map(v =&gt; (\n                            &lt;div&gt;\n                                {v}\n                            &lt;/div&gt;\n                        ))\n                    }\n\n                    &lt;div className=&quot;mt30 mb30&quot; style={{textAlign: &quot;center&quot;}}&gt;\n                        {finished ? (\n                            &#39;暂无更多日志&#39;\n                        ) : (\n                            &lt;Icon type=&quot;loading&quot; /&gt;\n                        )}\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/Modal&gt;\n        )\n    }\n}\n</code></pre>"},function(e,n,t){var r="<h3 id=一个icon-方案>一个Icon 方案</h3> <p><img src="+t(100)(t(268))+" alt=目录结构></p> <p>从./icons 目录读取 每个 svg 并 通过wrap 函数 包裹 成 一个个 react 组件, 每新增一个icon 运行node ./create.js</p> <h4 id=createjs>create.js</h4> <pre><code>const fs = require(&#39;fs&#39;)\n\nconst icons = fs.readdirSync(&#39;./icons&#39;)\n\nconst nameArray = icons.reduce((pre, v) =&gt; {\n    const name = v.split(&#39;.&#39;)[0]\n    if (name) {\n        pre.push(name)\n    }\n    return pre\n}, [])\n\n// index.js import 模板\nconst importTemp = () =&gt; `import wrap from &#39;./wrap&#39;`\n\n// index.js 模板\nconst indexTemplate = () =&gt;\n    `${importTemp()}\n\n${nameArray\n    .map(v =&gt; `const ${v.toUpperCase()} = wrap(require(&#39;./icons/${v}.svg&#39;))`)\n    .join(&#39;\\n&#39;)}\n\nmodule.exports = {\n${nameArray.map(v =&gt; `  ${v.toUpperCase()}`).join(&#39;,\\n&#39;)}\n}\n`\n\nfs.writeFileSync(&#39;./index.js&#39;, indexTemplate())\n</code></pre><h4 id=wrapjs>wrap.js</h4> <pre><code>const wrap = src =&gt; {\n    return ({ style, size, width, height, ...rest }) =&gt; (\n        &lt;div\n            style={{\n                display: &#39;inline-flex&#39;,\n                width: size || height || 14,\n                height: size || width || 14,\n                minHeight: size || height || 14,\n                minWidth: size || width || 14,\n                ...(style || {})\n            }}\n            {...rest}\n        &gt;\n            &lt;img style={{ width: &#39;100%&#39;, height: &#39;100%&#39; }} src={src} alt /&gt;\n        &lt;/div&gt;\n    )\n}\n\nexport default wrap</code></pre><h4 id=indexjs-示例>index.js 示例</h4> <pre><code>import wrap from &#39;./wrap&#39;\n\nconst ADD = wrap(require(&#39;./icons/add.svg&#39;))\nconst AMR = wrap(require(&#39;./icons/amr.svg&#39;))\nconst CLOUDFILE = wrap(require(&#39;./icons/cloudFile.svg&#39;))\nconst DATASOURCE = wrap(require(&#39;./icons/datasource.svg&#39;))\nconst DELETE = wrap(require(&#39;./icons/delete.svg&#39;))\nconst DIR = wrap(require(&#39;./icons/dir.svg&#39;))\nconst DOC = wrap(require(&#39;./icons/doc.svg&#39;))\nconst DOCX = wrap(require(&#39;./icons/docx.svg&#39;))\nconst DOWNLOAD = wrap(require(&#39;./icons/download.svg&#39;))\nconst EMPTY = wrap(require(&#39;./icons/empty.svg&#39;))\nconst GANTANHAO = wrap(require(&#39;./icons/gantanhao.svg&#39;))\nconst GIF = wrap(require(&#39;./icons/gif.svg&#39;))\nconst HTML = wrap(require(&#39;./icons/html.svg&#39;))\nconst JPG = wrap(require(&#39;./icons/jpg.svg&#39;))\nconst MOV = wrap(require(&#39;./icons/mov.svg&#39;))\nconst MP3 = wrap(require(&#39;./icons/mp3.svg&#39;))\nconst MP4 = wrap(require(&#39;./icons/mp4.svg&#39;))\nconst OTHER = wrap(require(&#39;./icons/other.svg&#39;))\nconst PDF = wrap(require(&#39;./icons/pdf.svg&#39;))\nconst PNG = wrap(require(&#39;./icons/png.svg&#39;))\nconst PPT = wrap(require(&#39;./icons/ppt.svg&#39;))\nconst PROJECT = wrap(require(&#39;./icons/project.svg&#39;))\nconst RAR = wrap(require(&#39;./icons/rar.svg&#39;))\nconst REFRESH = wrap(require(&#39;./icons/refresh.svg&#39;))\nconst SEARCH = wrap(require(&#39;./icons/search.svg&#39;))\nconst SEVENZ = wrap(require(&#39;./icons/sevenZ.svg&#39;))\nconst SVG = wrap(require(&#39;./icons/svg.svg&#39;))\nconst TABLE = wrap(require(&#39;./icons/table.svg&#39;))\nconst TRANSHISTORY = wrap(require(&#39;./icons/transHistory.svg&#39;))\nconst TXT = wrap(require(&#39;./icons/txt.svg&#39;))\nconst ZIP = wrap(require(&#39;./icons/zip.svg&#39;))\nconst ZIPFILE = wrap(require(&#39;./icons/zipfile.svg&#39;))\nconst ZOOMOUT = wrap(require(&#39;./icons/zoomOut.svg&#39;))\nconst LOGO = wrap(require(&#39;./icons/logo.svg&#39;))\n\nmodule.exports = {\n    ADD,\n    AMR,\n    LOGO,\n    CLOUDFILE,\n    DATASOURCE,\n    DELETE,\n    DIR,\n    DOC,\n    DOCX,\n    DOWNLOAD,\n    EMPTY,\n    GANTANHAO,\n    GIF,\n    HTML,\n    JPG,\n    MOV,\n    MP3,\n    MP4,\n    OTHER,\n    PDF,\n    PNG,\n    PPT,\n    PROJECT,\n    RAR,\n    REFRESH,\n    SEARCH,\n    SEVENZ,\n    SVG,\n    TABLE,\n    TRANSHISTORY,\n    TXT,\n    ZIP,\n    ZIPFILE,\n    ZOOMOUT\n}\n</code></pre><p>使用 eg</p> <pre><code>import { ADD } from &#39;xxx&#39;\n\nimport Icons from &#39;xxx&#39;\n\n\n&lt;ADD size={14} /&gt;\n&lt;Icons.ADD size={14} /&gt;</code></pre>";e.exports=r},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/icons-catalog.png?ae25da8808f1cbddcf9a0e1785a36949"},function(e,n){e.exports="<h3 id=神仙源码>神仙源码</h3> <p><a href=https://zhuanlan.zhihu.com/p/108289604>源地址</a></p> <h4 id=实现一个new操作符>实现一个new操作符</h4> <p>new 做了什么</p> <p>1.创建一个空的简单JavaScript对象（即{}）； 2.链接该对象（即设置该对象的构造函数）到另一个对象； 3.将步骤（1）新创建的对象作为this的上下文； 4.如果该函数没有返回对象，则返回this。（是引用类型则返回对象，值类型返回this）</p> <pre><code>function create(context, ...args) {\n  // 创建一个空对象\n  this.obj = {}\n\n  // 将空对象指向构造函数的原型链\n  Object.setPrototypeOf(this.obj, context.prototype)\n\n  // 将obj绑定到构造函数上，便可以直接访问构造函数中的属性，即this.obj.context(args)\n  const result = context.apply(this.obj, args)\n\n  // 如果返回的result是一个对象则返回\n  // new 方法失效，否则返回obj\n  return result instanceof Object ? result : this.obj\n}</code></pre><h4 id=实现一个arrayisarray>实现一个Array.isArray</h4> <p>利用Object.prototype.toString</p> <pre><code>Array.myIsArray = function(e) {\n  return Object.prototype.toString.call(Object(e)) === &#39;[object Array]&#39;\n}</code></pre><h4 id=实现一个objectcreate方法>实现一个Object.create()方法</h4> <pre><code>const create = e =&gt; {\n  const F = function() {}\n  F.prototype = F\n  return new F()\n}</code></pre><h4 id=实现一个eventemitter-类>实现一个EventEmitter 类</h4> <pre><code>class Event {\n  constructor() {\n    this.subscriber = {}\n  }\n\n  on(type, callback) {\n    const _curSubscriber = this.subscriber[type] || []\n\n    // 判断有木有\n    if (_curSubscriber.includes(callback)) {\n      return this\n    }\n\n    this.subscriber[type] = [..._curSubscriber, callback]\n\n    return this\n  }\n\n  off(type, callback) {\n    const _curSubscriber = this.subscriber[type]\n\n    if (callback) {\n      _curSubscriber &amp;&amp; (this.subscriber[type] = _curSubscriber.filter(item =&gt; item !== callback))\n    } else {\n      _curSubscriber &amp;&amp; (delete this.subscriber[type])\n    }\n\n    return this\n  }\n\n  emit(type, ...param) {\n    const _curSubscriber = this.subscriber[type] || []\n\n    _curSubscriber.forEach(callback =&gt; {\n        callback(param)\n    })\n\n    return this\n  }\n\n  once(type, callback) {\n    const _onceFun = () =&gt; {\n      callback.apply(this)\n      this.off(type, _onceFun)\n    }\n\n    this.on(type, _onceFun)\n  }\n\n  removeAll() {\n    this.subscriber = {}\n\n    return this\n  }\n}</code></pre><h4 id=实现一个arrayprototypereduce>实现一个Array.prototype.reduce</h4> <p><code>Array.prototype.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</code></p> <pre><code>Array.prototype.myReduce = function(callback, initialValue) {\n  let result = initialValue !== undefined ? initialValue : this[0]\n\n  for (let i = initialValue !== undefined ? 0 : 1; i &lt; this.length; i++) {\n    result = callback(result, this[i], i, this)\n  }\n\n  return result\n}</code></pre><h4 id=实现一个call--apply>实现一个Call || Apply</h4> <p>call 分两步 改变函数this 指向，然后 执行函数</p> <pre><code>Function.prototype.myCall = function(context) {\n  context = context || window\n\n  context.fn = this\n\n  // 获取其余参数\n  const [source, ...rest] = [...arguments]\n\n  const result = context.fn(...rest)\n\n  delete context.fn\n  return result\n}</code></pre><p>myApply的参数形式为(obj,[arg1,arg2,arg3]) 所以myApply的第二个参数为[arg1,arg2,arg3]</p> <pre><code>Function.prototype.myApply = function(context) {\n  context = context || window\n\n  context.fn = this\n\n  const rest = [...arguments][1]\n\n  const result = context.fn(...rest)\n\n  delete context.fn\n  return result\n}</code></pre><pre><code>Function.prototype.myBind = function() {\n  const _this = this\n\n  const [source, ...rest] = [...arguments]\n\n  // 创建一个函数,并执行合并之后的参数\n  const fn = function() {\n    const _rest = [...arguments]\n\n    // 区分 引用类型和值类型\n    const _source = this instanceof fn ? this : source\n\n    _this.apply(_source, rest.concat(_rest))\n  }\n\n  //添加原函数所有的prototype的值\n  fn.prototype = Object.create(this.prototype)\n\n  return fn\n}</code></pre><h4 id=js函数柯里化>JS函数柯里化</h4> <pre><code>function curry(fn) {\n  // 第一遍运行length是函数fn一共需要的参数个数，以后是剩余所需要的参数个数\n  const length = fn.length\n\n  return function judge() {\n    const _args = [...arguments]\n\n    if (_args.length &lt; length) {\n      return function() {\n        return judge(..._args, ...arguments)\n      }\n    }\n\n    // 参数收集 完成，执行该函数\n    return fn(..._args)\n  }\n}\n\nlet curryFun = curry((a, b, c) =&gt; console.log(a, b, c))\n\ncurryFun(1)(2)(3)</code></pre><pre><code>function add() {\n  let _args = [...arguments]\n\n  let action = function() {\n    _args = [..._args, ...arguments]\n\n    // 收集参数完毕\n    if (arguments.length === 0) {\n      return _args.reduce((pre, val) =&gt; {\n        return pre + val\n      }, 0)\n    }\n\n    return action\n  }\n\n  return action\n}\n\nadd(1)(2)(3)()\nadd(1, 2, 3)(4)()</code></pre><pre><code>function add() {\n  let _args = [...arguments]\n\n  let action = function() {\n    _args = [..._args, ...arguments]\n\n    return action\n  }\n\n  action.toString = function () {\n    return _args.reduce((pre, val) =&gt; {\n      return pre + val\n    }, 0)\n  }\n\n  return action\n}\n\nadd(1)(2)(3) // f 6\n+add(1)(2)(3) // 6\nadd(1, 2, 3)(4)</code></pre><h4 id=手写防抖（debounce）-和-节流（throttle）>手写防抖（Debounce） 和 节流（Throttle）</h4> <p>防抖 间隔时间内，重复触发，更新触发间隔</p> <pre><code>function debounce(fun, wait) {\n  let timeout\n  return function() {\n    const _this = this\n    const args = arguments\n\n    if (timeout) {\n      clearTimeout(timeout)\n    }\n\n    timeout = setTimeout(() =&gt; {\n      fun.apply(_this, args)\n\n      timeout = undefined\n    }, wait)\n  }\n}\n</code></pre><p>节流 间隔时间内，重重触发无效果,只触发一次</p> <pre><code>function throttle(fun, delay) {\n  let preTime = Date.now()\n  return function() {\n    const curTime = Date.now() \n\n    if (curTime - preTime &gt; delay) {\n      fun.apply(this, arguments)\n\n      preTime = curTime\n    }\n  }\n}\n</code></pre><h4 id=深拷贝-深度优先>深拷贝 深度优先</h4> <pre><code>function deepClone(source) {\n   // typeof null 也是 object\n  if (source !== null &amp;&amp; typeof source === &#39;object&#39;) {\n    const _target = Array.isArray(source) ? [] : {}\n\n    for (const i in source) {\n      if (typeof source === &#39;object&#39;) {\n        _target[i] = deepClone(source[i])\n      } else {\n        _target[i] = source[i]\n      }\n    }\n\n    return _target\n  } else {\n    return source\n  }\n}</code></pre><h4 id=实现一个arrayprototypeflat>实现一个Array.prototype.flat()</h4> <pre><code>Array.prototype.myFlat = function(depth = 1) {\n  return this.reduce((pre, value) =&gt; {\n    if (Array.isArray(value)) {\n      // 不循环\n      if (!Number(depth) || Number(depth) === 0) {\n        pre.push(value)\n      } else {\n        pre.push(value.myFlat(depth - 1))\n      }\n    }\n\n    return pre \n  }, [])\n}</code></pre><h4 id=实现一个双向绑定>实现一个双向绑定</h4> <p>Vue 2.x的Object.defineProperty版本</p> <pre><code>// 数据\nconst data = {\n  text: &#39;test&#39;\n}\n\nconst input = document.getElementById(&#39;input&#39;)\nconst span = document.getElementById(&#39;span&#39;)\n\n// 数据劫持\nObject.defineProperty(data, &#39;text&#39;, {\n  // 数据变化 —&gt; 修改视图\n  set(newVal) {\n    input.value = newVal;\n    span.innerHTML = newVal;\n  }\n})\n\n// 视图更改 --&gt; 数据变化\ninput.addEventListener(&#39;keyup&#39;, function(e) {\n  data.text = e.target.value;\n});</code></pre><pre><code>// 数据\nconst data = {\n  text: &#39;default&#39;\n};\nconst input = document.getElementById(&#39;input&#39;);\nconst span = document.getElementById(&#39;span&#39;);\n// 数据劫持\nconst handler = {\n  set(target, key, value) {\n    target[key] = value;\n    // 数据变化 —&gt; 修改视图\n    input.value = value;\n    span.innerHTML = value;\n    return value;\n  }\n};\nconst proxy = new Proxy(data, handler);\n\n// 视图更改 --&gt; 数据变化\ninput.addEventListener(&#39;keyup&#39;, function(e) {\n  proxy.text = e.target.value;\n});</code></pre>"},function(e,n){e.exports="<h3 id=好好理解一下-plugin>好好理解一下 plugin</h3> <p>webpack是一个打包模块化js的工具，可以通过loader转换文件，通过plugin扩展功能</p> <p><a href=https://www.webpackjs.com/api/plugins/#tapable>plugin API</a></p> "},function(e,n){e.exports=""},function(e,n){e.exports="<h3 id=手写上传>手写上传</h3> <pre><code>const formData = new FormData() // 新建formData对象\n\nformData.append(&#39;file&#39;, originFileObj) // 将file添加到formData传到后端\nformData.append(&#39;uploadId&#39;, uploadId) // 将 viewPath 添加到formData传到后端\n\nconst xhr = new XMLHttpRequest() // 新建ajax异步对象,将当前xhr 写入 process, 保存当前进程\n\nxhr.open(&#39;post&#39;, `${urlPrefix}file_upload/file?uploadId=${uploadId}`) // 打开ajax\n// 监听ajax对象事件状态\n// readyState\n// 0: 请求未初始化\n// 1: 服务器连接已建立\n// 2: 请求已接收\n// 3: 请求处理中\n// 4: 请求已完成，且响应已就绪\nxhr.onreadystatechange = function() {\n    console.log(&#39;onreadystatechange ------------&#39;, xhr)\n\n    if (xhr.readyState == 4) {\n        if (xhr.status == 200) {\n            const response = JSON.parse(xhr.response)\n\n            if (response.success) {\n                setStatus(&#39;DONE&#39;)\n                setProgress(100)\n            } else {\n                ErrorEater(response)\n                setStatus(&#39;ERROR&#39;)\n            }\n        }\n        else {\n            setStatus(&#39;ERROR&#39;)\n        }\n\n        emitter.emit(`file_upload_done_${uid}`)\n        emitter.emit(&#39;file_upload_task_done&#39;)\n        emitter.emit(`file_upload_process_delete`, uid)\n    }\n}\n\n// 监听文件上传进度\nxhr.upload.onprogress = function(ev) {\n    if (ev.lengthComputable) {\n        const progress = Math.floor((ev.loaded / ev.total) * 100)\n\n        if (_status === &#39;CANCEL&#39; || _status === &#39;ERROR&#39;) return\n\n        if (_status === &#39;WAITING&#39;) setStatus(&#39;UPLOADING&#39;)\n\n        if (progress === 100) return\n\n        setProgress(progress)\n    }\n}\n\nxhr.send(formData) // 发送ajax请求将formData对象发送过去</code></pre>"},function(e,n){e.exports="<h3 id=filereaderreadasdataurl>FileReader.readAsDataURL()</h3> <p><a href=https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsDataURL>FileReader.readAsDataURL()</a></p> <pre><code>&lt;input type=&quot;file&quot; onchange=&quot;previewFile()&quot;&gt;&lt;br&gt;\n&lt;img src=&quot;&quot; height=&quot;200&quot; alt=&quot;Image preview...&quot;&gt;\n\n\nfunction previewFile() {\n  var preview = document.querySelector(&#39;img&#39;);\n  var file    = document.querySelector(&#39;input[type=file]&#39;).files[0];\n  var reader  = new FileReader();\n\n  reader.addEventListener(&quot;load&quot;, function () {\n    preview.src = reader.result;\n  }, false);\n\n  if (file) {\n    reader.readAsDataURL(file);\n  }\n}</code></pre>"},function(e,n,t){var r=t(100),o=t(275),a=t(276),i=t(277),s=t(278),p="<h3 id=react-核心思想>React 核心思想</h3> <p>内存中维护一棵 虚拟DOM树，数据变化时（setState），自动更新虚拟Dom树，得到一棵新树，然后Diff新旧两颗树，找到有变化的部分，得到一个Change（Patch），将这个Patch添加到队列中，最终批量更新这些Patch到DOM中</p> <h3 id=react-16-之前的不足>React 16 之前的不足</h3> <p>首先我们先了解下React的工作过程，当我们通过<code>render()</code>和<code>setState()</code>进行组件渲染和更新的时候，React主要有两个阶段 <img src="+r(o)+' alt="alt react16 之前的 更新"></p> <p>调和阶段（Reconciler）：官方解释，React 会从上而下通过递归，遍历新数据生成新的Virtual DOM，然后通过Diff算法，找到需要变更的元素（Patch），放到更新队列里面去。 渲染阶段（Rendderer）：遍历更新队列，通过调用宿主环境API，实际更新渲染对应元素。宿主环境，比如DOM，NATIVE，WebGL等。</p> <p>在调和阶段，由于采用的递归的遍历方式，这种也被称为Stack Reconciler，主要是为了区别Fiber Reconciler取的一个名字。这种方式有一个特点：一旦任务开始进行，就无法中断，那么js将一直占用主进程，一直等整棵虚拟DOM树计算完成之后，才能把执行权交给渲染引擎，那么就会导致一些用户交互、动画等任务无法立即得到处理，就会有卡顿，非常影响用户体验。</p> <h3 id=如何解决之前的不足>如何解决之前的不足</h3> <blockquote> <p>之前的问题主要是任务一但执行，就无法中断，js线程一直占用主线程，导致卡顿</p> </blockquote> <h4 id=浏览器每一帧都需要完成哪些工作>浏览器每一帧都需要完成哪些工作?</h4> <p>页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到60时，页面是流畅的，小于这个值时，用户会感觉到卡顿。</p> <p>1s 60帧，每一帧分到的时间是 1000 / 60 大约 16ms。所以我们书写代码是力求 不让一帧的 工作量 耗时 超过16ms</p> <p><img src='+r(a)+' alt="alt 浏览器一帧内的工作"></p> <h5 id=浏览器内一帧的工作>浏览器内一帧的工作</h5> <p>通过上图可看到，一帧内需要完成如下六个步骤的任务：</p> <ul> <li>处理用户的交互</li> <li>JS解析执行</li> <li>帧开始。窗户尺寸变更，页面滚动等处理</li> <li>requestAnimationFrame</li> <li>布局</li> <li>绘制</li> </ul> <p>如果这六个步骤中，任意一个步骤所占用的时间过长，总时间超过了16ms之后，用户也许会感觉卡顿。</p> <p>而在上一小节所说到的调和阶段耗时比较长，也就是js执行耗时过长，那么就有可能在用户有交互的时候，本来应该渲染下一帧了，但是还在下一帧中执行js，就导致用户交互不能到马上得到反馈，从而产生卡顿感。</p> <h4 id=解决方案>解决方案</h4> <p>把渲染过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩下的时间，如果有，继续下一个任务；否则，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候，再继续执行。这种策略称为 <code>Cooperative Scheduling（合作式调度）</code>，操作系统常用的任务调度策略之一。</p> <p>合作式调度主要就是用来分配任务的，当有更新任务传来的时候，不马上做Diff操作，而是先把当前的更新送入到一个 Update Quene 中，再交给 Scheduler 去处理，Scheduler 会根据当前主线程的使用情况去处理当前 Update。为了实现这种特性，使用了<code>requestIdleCallback</code>API。对于不支持该API的浏览器，React会加上pollyfill。</p> <p>在上面我们已经知道了浏览器是一帧一帧执行的，在两个执行帧间，主线程通常会有一小段空闲时间，<code>requestIdleCallback</code>可以在这个<code>空闲期（Idle Period）调用空闲回调（Idle Callback）</code>，执行一些任务。</p> <p><img src='+r(i)+' alt="alt react idle period task"></p> <ul> <li>低优先级的任务由requestIdleCallback</li> <li>高优先级的任务，如动画相关的交由requestAnimationFrame处理</li> <li>requestIdleCallback可以在多个空闲期回调，执行任务</li> <li>requestIdleCallback方法提供deadline，即任务执行限制时间，以切分任务，避免长时间运行，阻塞UI渲染而导致掉帧</li> </ul> <p>这个方案看起来确实不错，但是怎么实现可能会遇到几个问题：</p> <ul> <li>如何拆分成子任务？</li> <li>一个子任务多大合适？</li> <li>怎么判断是否还有剩余时间？</li> <li>有剩余时间怎么去调度应该执行哪个任务？</li> <li>没有剩余时间任务会怎么办？</li> </ul> <p>接下来整个Fiber架构就是来解决这些问题的。</p> <h3 id=什么是fiber>什么是Fiber</h3> <p>为了解决上面提出的问题，提出了以下几个目标：</p> <ul> <li>暂停工作，稍后再回来</li> <li>为不同类型任务分配优先权（设置权重）</li> <li>重用以前完成的工作</li> <li>如果不再需要，则中止任务</li> </ul> <p>为了做到这些，我们首先需要一种方法将任务分解为单元。从某种意义上讲，Fiber代表工作单元。</p> <p>但是仅仅分解为单元还是不能做到中断任务，因为函数调用栈就是这样，每个函数为一个工作，每个工作被称为堆栈帧，它会一直工作，直到堆栈为空，无法中断。</p> <p>因此Fiber就是重复实现的堆栈帧，本质上Fiber 可以理解为一个虚拟的堆栈帧，将可中断的任务拆解为多个子任务，通过按照优先级来自由调度子任务，分段更新，从而将之前的渲染改为异步渲染。</p> <p>所以我们可以说Fiber 是一种数据结构（堆栈帧），也可以说是一种解决可中断地调用任务的一种解决方案，它的特性就是 <code>时间分片（Time Slicing）</code> 和 <code>暂停（Supense）</code></p> <blockquote> <p>如果了解协程的话可能会觉得Fiber的这种解决方案，跟协程有点像（还是有很大区别），是可中断的，可以控制执行顺序。在JS 的 Generator 其实就是一种协程的使用方式，不过颗粒度更小，可以控制函数里面的代码调用的顺序，也可以中断。</p> </blockquote> <h3 id=fiber-是-如何工作的>Fiber 是 如何工作的</h3> <ol> <li><code>ReactDOM.render()</code> <code>setState</code>的时候开始创建更新</li> <li>将创建的更新加入任务队列，等待调度</li> <li>在requestIdleCallback空闲时执行</li> <li>从根节点开始遍历Fiber Node，并且构建 WorkInProgress Tree</li> <li>生成EffectList</li> <li>根据EffectList更新DOM</li> </ol> <p><img src='+r(s)+' alt="alt react fiber progress"></p> <ol> <li>第一部分从<code>ReactDOM.render()</code> 方法开始，把接收到的React Element转换为Fiber节点，并为其设置优先级，创建Update，加入到更新队列，这部分主要做一些初始数据的准备</li> <li>第二部分主要是三个函数：<code>scheduleWork</code> <code>requestWork</code> <code>performWork</code>，安排工作、申请工作、正式工作三个部分，React16 新增的异步调用功能则在这部分实现，这部分就是Schedule阶段，前面介绍的Cooperative Scheduling就是在这个阶段，只有在这里解决获取到可执行的时间片，第三部分才会继续执行。具体如何调度的，后面文章再介绍，这是React调度的关键过程。</li> <li>第三部分是个大循环，遍历所有的Fiber节点，通过Diff算法计算所有更新工作，产出EffecList给到commit阶段使用，这部分核心是beginWork函数，这部分基本就是Fiber reconciliation 和 commit 阶段。</li> </ol> <h3 id=fiber-node>Fiber Node</h3> <p>Fiber Node，承接了非常关键的上下文信息，可以说是贯穿了真个创建和更新过程，下面分组列了一些重要的Fiber字段。</p> <pre><code>{\n  ...\n  // 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）\n  stateNode: any, \n\n  // 单链表结构\n  return: Fiber | null, // 指向他在Fiber节点树中的 parent， 用来处理完这个节点之后向上返回\n  child: Fiber | null, // 指向自己的第一个子节点\n  sibling:  Fiber | null,  // 指向自己的兄弟节点， 兄弟节点的return 指向同一个父节点\n\n  // 更新相关\n  pendingProps: any, // 新的变动带来的新的props\n  memoizedProps: any,  // 上一次渲染完成之后的props\n  updateQueue: UpdateQueue&lt;any&gt; | null, // 该Fiber对应的组件产生的Update会存放在这个队列中\n  memoizedState: any, // 上一次渲染时的state\n\n  // Scheduler 相关\n  expirationTime: ExpirationTime, // 代表任务未来的哪个时间点应该被完成，不包括它的子树产生的任务\n  // 快速确定子树中是否有不再等待的变化\n  childExpirationTime: ExpirationTime,\n\n  // 在Fiber树更新的过程中，每一个Fiber都有一个对应的Fiber\n  // 我们称为 current -&gt; workInProgress\n  // 在渲染完成之后它们会交换位置\n  alternate: Fiber | null,\n\n  // Effect 相关  \n  effectTag: SideEffectTag, // 用来记录Side Effect\n  nextEffect: Fiber | null, // 单链表用来快速查找下一个sideEffect\n  firstEffect: Fiber | null,  // 子树中第一个side effect\n  lastEffect: Fiber | null, // 子树中最后一个side effect\n  ....\n}</code></pre><h3 id=fiber-reconciler>Fiber Reconciler</h3> <p>在第二部分，进行Scheduler完，获取到时间片之后，就开始进行reconcile。</p> <p>Fiber Reconciler 是 React 中的 调和器，这也是任务调度完成之后，如何去执行每个任务，如何去更新每个节点的过程，对应上面的第三部分。</p> <h3 id=fiber>Fiber</h3> <p>背景 我们知道 React 是通过递归的方式来渲染组件的，在 V16 版本之前的版本里，当一个状态发生变更时，react 会从当前组件开始，依次递归调用所有的子组件生命周期钩子，而且这个过程是同步执行的且无法中断的，一旦有很深很深的组件嵌套，就会造成严重的页面卡顿，影响用户体验。</p> <p>React 在V16版本之前的版本里引入了 Fiber 这样一个东西，它的英文涵义为纤维，在计算机领域它排在在进程和线程的后面，虽然 React 的 Fiber 和计算机调度里的概念不一样，但是可以方便对比理解，我们大概可以想象到 Fiber 可能是一个比线程还短的时间片段。</p> <h4 id=fiber-到底做了什么事>Fiber 到底做了什么事</h4> <p>Fiber 把当前需要执行的任务分成一个个微任务，安排优先级，然后依次处理，每过一段时间（非常短，毫秒级）就会暂停当前的任务，查看有没有优先级较高的任务，然后暂停（也可能会完全放弃）掉之前的执行结果，跳出到下一个微任务。同时 Fiber 还做了一些优化，可以保持住之前运行的结果以到达复用目的。</p> <h4 id=举个潜水员的例子>举个潜水员的例子</h4> <p>我们可以把调度当成一个潜水员在海底寻宝，v16 之前是通过组件递归的方式进行寻宝，从父组件开始一层一层深入到最里面的子组件</p> <p>而替换成了 Fiber 后，海底变成的狭缝（简单理解为递归变成了遍历），潜水员会每隔一小段时间浮出水面，看看有没有其他寻宝任务。注意此时没有寻到宝藏的话，那么之前潜水的时间就浪费了。就这样潜水员会一直下潜和冒泡</p> <h4 id=时间分片>时间分片</h4> <p>原理： 在每一帧的中会先执行 macrotasks 任务 -&gt; 再执行 UI rendering -&gt; 最后有剩余时间执行 Idle 回调</p> <p>react 16 之前，react 通过虚拟 dom 更新是同步的，一旦有更新就会一直执行到更新完毕, 如果更新很复杂就会一直占用浏览器主线程，这时候浏览器本身的动画和用户输入操作就会出现卡顿或没响应。</p> <p>react 16 后，采用时间片的方式解决更新卡顿的问题。 给每个 react 更新任务一个过期时间 timeout，维护一个 react 更新队列 通过 requestAnimationFrame 找到每一帧的开始时间，再计算出下一帧的开始时间 把优先级最高的 react 更新任务推入 event loop 的 tasks queue 中 每次 event loop 开始 react 更新的 tasks 时都会检查这个任务是否到期 timeout 了，只有 timeout 时才会执行 react 更新任务会先进入 renderRoot 渲染阶段更新 fiberTree 上的内容，再进行 completeRoot 提交阶段更改 dom 的最终结果。 react 更新任务 didTimeout 过期时执行 renderRoot ，这个渲染阶段哪怕时间很长也最大限度的保证了浏览器高优先级别的动画和用户输入的流畅运行</p> <p>调度时通过 requestAnimationFrame api 在浏览器每次重绘前做想做的事 requestAnimationFrame 回调 animationTick 在浏览器动画执行前 执行 他在 animationTick 中确定了下一帧结束的时间点 因为不知道 react 更新需要多少时间，所以没有在 animationTick 中判断 timeRemaining() 当前帧剩余时间来执行 react 更新 而是把用于 react 更新的 flushWork 通过 postMessage 推入下个 tick 事件队列中的 idleTick 回调，也就是 macrotasks 在 window.addEventListener(‘message’, idleTick, false); 的 idleTick 中一直拖到 frameDeadline - currentTime &lt;= 0 当前帧完全过期时 才把 didTimeout = true, 再 执行 prevScheduledCallback(didTimeout); - flushWork(didTimout) 这次 react 更新。 这次 macrotasks 的 flushWork 先于 requestAnimationFrame 执行 这时 flushWork 就算更新时间超过当前帧剩余时间借用了下一帧的时间，也是最大限度的保证了浏览器动画的流畅性和优先级。</p> ';e.exports=p},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/react-update-before-16.png?4b324c10e85b6818d6e8480c9b4d8f43"},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/life-of-a-frame.png?4028af638048e722c95e4d1293b101c8"},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/react-idle-period-task.png?2ed7a260c747f1536cdb1c7bd6ab6702"},function(e,n,t){"use strict";t.r(n),n.default=t.p+"images/react-fiber-progress.png?5e0ace0896de943f39542132297cdbb2"},function(e,n){e.exports="<h3 id=setstate>setState</h3> <p>异步执行更新</p> <p>同一段时间内 setState 在同一任务队列内 批量更新视图</p> <h3 id=usestate>useState</h3> <p>hooks 本质是 闭包</p> <p>react 为每个组件 创建了 memoizedState和index，并且放在对应的虚拟dom上，这样，假如App() 有m，Example() 也有m，不会重复</p> <p>Hooks 的 数据结构 memoizedState 也是一个数组，准确来说 React 的 Hooks 是一个单向链表，Hook.next 指向下一个 Hook</p> <p>memoizedState <code>这个key用来存储在上次渲染过程中最终获得的节点的state，每次render之前，React会计算出当前组件最新的state然后赋值给组件，再执行render。</code></p> <p>同一个 函数 内 定义的 useState 值会存放在 一个 memoizedState 数组, set 的更新 操作 会 存放在一个链表 内</p> <p>对应 state 的 更新下标 是固定的 </p> <p>不能在循环、条件或嵌套函数中调用，会导致 setState 时 下标 不一致导致 错误</p> <p>为了保证 memoizedState 的顺序与 React.useState() 正确对应，我们需要保证 Hooks 在最顶层调用，也就是不能在循环、条件或嵌套函数中调用。</p> <p>React.useState() 通过 Object.is() 来判断 memoizedState 是否需要更新。</p> <p>更新逻辑</p> <pre><code>numberOfReRenders 记录了 re-render 的次数，如果大于 0 说明当前更新周期中又产生了新的更新，那么就继续执行这些更新，根据 reducer 和 update.action 来创建新的 state，直到当前渲染周期中没有更新为止，最后赋值给 Hook.memoizedState 以及 Hook.baseState。</code></pre>"},function(e,n){e.exports="<pre><code>class BigNumberCalc {\n    multiplication () {\n        let maxLength = 0\n        let index = 0\n        let result = []\n        let decimal = 0 \n\n        const args = [...arguments].map(v =&gt; {\n            const _varr = `${v}`.split(&#39;&#39;).reverse()\n            maxLength = _varr.length &gt; maxLength ? _varr.length : maxLength\n            return _varr\n        })\n\n        while(index &lt; maxLength) {\n            const _sum = args.reduce((pre, value) =&gt; {\n                return +(value[index] || 0) + pre\n            }, decimal)\n\n            const _arr = `${_sum}`.split(&#39;&#39;)\n\n            if (index === maxLength - 1) {\n                result.unshift(_sum)\n                index ++\n                break \n            }\n\n            if (_sum &gt; 10) {\n                result.unshift(+_arr.pop())\n                decimal = Number(_arr.join())\n            } else {\n                result.unshift(_sum)\n                decimal = 0\n            }\n\n            index++\n        }\n\n        return result.join(&#39;&#39;)\n    }\n}\n\nvar a = new BigNumberCalc()\n\na.multiplication(111111111111, 222222222222, 777777777777)\n</code></pre>"},function(e,n){e.exports="<pre><code>const fib = length =&gt; {\n    const _wrap = new Array(length).fill(&#39;a&#39;)\n\n    const isSecond = index =&gt; index === 0 || index === 1\n\n    const fib = _wrap.reduce((pre, value, index) =&gt; {\n        if(isSecond(index)) {\n            pre.push(1)\n        } else {\n            pre.push(pre[index - 1] + pre[index - 2])\n        }\n\n        return pre\n    }, [])\n\n    return fib\n}</code></pre>"},function(e,n){e.exports="<h3 id=找最少硬币数（动态规划）>找最少硬币数（动态规划）</h3> <p>JS求组成n块的最少硬币数 (单个面值只有一块、五块、七块)</p> <pre><code>var getGroup = sum =&gt; {\n  const result = {}\n  let rest = 0\n\n  // \b整除\n  if (sum % 7 === 0) {\n    result[&#39;7&#39;] = sum / 7\n    return result\n  }\n\n  // 等于自身\n  if (sum % 7 === sum) {\n    result[&#39;7&#39;] = 0\n    rest = sum\n  } else {\n    result[&#39;7&#39;] = (sum - sum % 7) / 7\n    rest = sum % 7\n  }\n\n  if (rest % 5 === 0) {\n    result[&#39;5&#39;] = res / 5\n    return result\n  }\n\n  if (rest % 5 === rest) {\n    result[&#39;5&#39;] = 0\n    result[&#39;1&#39;] = rest \n  } else {\n    result[&#39;5&#39;] = (rest - rest % 5) / 5\n    result[&#39;1&#39;] = rest % 5 \n  }\n\n  return result\n}\n\ngetGroup(9)</code></pre>"},function(e,n){e.exports="<pre><code>var getMixed = arrayList =&gt; {\n    return arrayList.reduce(((pre, value, index, array) =&gt; {\n        if (index === 0) {\n            return value\n        }\n\n        return Array.from(new Set(value)).reduce((_pre, _value, _index, _array) =&gt; {\n            if (pre.includes(_value)) {\n                _pre.push(_value)\n            } \n            return _pre\n        }, [])\n    }), [])\n}\n\ngetMixed([\n    [1,2,3,4,5],\n    [3,2,6],\n    [3,1,3,2,5],\n])</code></pre>"},function(e,n){e.exports="<h3 id=js>js</h3> <p>javascript -&gt; AST -&gt; 机器语言</p> "},function(e,n){e.exports="<h3 id=es6>es6</h3> <p>安装 @babel/node 编译</p> <p>babel-node index.js 启动</p> <h3 id=react-webpack-alias>react webpack alias</h3> <h3 id=按需加载>按需加载</h3> <h3 id=css-文件加载>css 文件加载</h3> "},function(e,n){e.exports="<p>最新的 ECMAScript 标准定义了 8 种数据类型:</p> <p>7 种原始类型: Boolean Null Undefined Number BigInt (new in ECMAScript 2020) String Symbol (new in ECMAScript 2015)</p> <p>和 Object</p> <p><a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures>传送门</a></p> "},function(e,n){e.exports="<pre><code>pip install opencv-python</code></pre><pre><code>import cv2  pylint报错\n\nsetting 文件加\n&quot;python.linting.pylintArgs&quot;: [&quot;--generate-members&quot;]</code></pre>"},function(e,n){e.exports="<pre><code>先升级 setuptools\npip install --upgrade setuptools</code></pre>"},function(e,n){e.exports="<pre><code>pip config set global.index-url http://mirrors.aliyun.com/pypi/simple/\npip config set install.trusted-host mirrors.aliyun.com\n</code></pre><pre><code>[global]\nindex-url = http://mirrors.aliyun.com/pypi/simple/\n\n[install]\ntrusted-host=\n  mirrors.aliyun.com</code></pre>"},function(e,n){e.exports="<p>&#39;可以用百度云离线下载&#39;</p> <pre><code>import os\nimport sys\nimport tarfile\n\nfrom six.moves import urllib\n\n# import tensorflow as tf\n\nDEST_DIR = &#39;cifar10_data/&#39;\nDATA_URL = &#39;http://www.cs.toronto.edu/~kriz/cifar-10-binary.tar.gz&#39;\n\n# Download and extract the tarball from Alex&#39;s website.\ndef download_and_extract(DATA_URL, DEST_DIR):\n  if not os.path.exists(DEST_DIR):\n    os.makedirs(DEST_DIR)\n\n  filename = DATA_URL.split(&#39;/&#39;)[-1]  # 文件名\n  filepath = os.path.join(DEST_DIR, filename)\n\n  if not os.path.exists(filepath):\n    # 文件下载函数\n    def _progress(count, block_size, total_size):\n        # %.1f%% -&gt; 实数后面输出1个 %\n        sys.stdout.write(&#39;\\r&gt;&gt; Downloading %s %.1f%%&#39; % (filename,\n                                                          float(count * block_size) / float(total_size) * 100.0))\n        sys.stdout.flush()  # 更新stdout\n\n    filepath, _ = urllib.request.urlretrieve(DATA_URL, filepath, _progress)\n    print()\n    statinfo = os.stat(filepath)\n    print(&#39;Successfully downloaded&#39;, filename, statinfo.st_size, &#39;bytes.&#39;)\n\n  # 提取 bin 文件路径\n  extracted_dir_path = os.path.join(DEST_DIR, &#39;cifar-10-batches-py&#39;)\n\n  if not os.path.exists(extracted_dir_path):\n    # Read from and write to tar format archives\n    tarfile.open(filepath, &#39;r:gz&#39;).extractall(DEST_DIR)\n\n\ndownload_and_extract(DATA_URL, DEST_DIR)\n</code></pre>"},function(e,n){e.exports="<pre><code>tf.matmul() 矩阵乘法 模拟 神经层 每层 的 运算\ntf.reduce_mean() 计算 tensor 张量 在 某个维度的 平均值\ntf.losses.categorical_crossentropy(y_true, y_pred) 交叉熵 交叉熵损失函数\n\nsoftmax就是模型已经有分类预测结果以后，将预测结果输入softmax函数，进行非负性和归一化处理，最后得到0-1之内的分类概率\n一步完成 概率分布 和 交叉熵 计算\n\ntf.nn.softmax_cross_entropy_with_logits(y_true, t_pred)</code></pre>"},function(e,n){e.exports="<p>欠拟合</p> <ul> <li>增加输入特征项</li> <li>增加网络参数</li> <li>减少增则参数</li> </ul> <p>过拟合</p> <ul> <li>数据清洗</li> <li>增大训练集</li> <li>采用正则化</li> <li>增大正则化参数</li> </ul> "},function(e,n){e.exports="<p>网路搭建 八股</p> <ul> <li>import 相关 模块</li> <li>读取 训练 数据 / 测试数据</li> <li>在 Sequential 中 逐层描述网络 (tf.keras.models.Sequential) 相当于走一遍前向传播</li> </ul> <pre><code>拉直层：tf.keras.layers.Flatten() 将数据拉直为 一维数组\n\n全联接层：tf.keras.layers.Dense(神经元个数, activation = &quot;激活函数&quot;, kernel_regulation = &quot;那种正则化&quot;)\n\nactivation 可选 relu softmax sigmoid tanh\nkernal_regulation 可选 tf.keras.regularizers.l1()\n\n卷积层：tf.keras.layers.Conv2D(filters = &quot;卷积核个数&quot;, kernel_size = &quot;卷积核大小&quot;, strides = &quot;步长&quot;, padding = &quot;valid / same&quot;)\n\nLSTM层：tf.keras.layers.LSTM()</code></pre><p>在Keras中，您可以组装图层来构建模型。 模型（通常）是图层图。 最常见的模型类型是一堆层：tf.keras.Sequential 模型。 构建一个简单的全连接网络（即多层感知器）：</p> <pre><code>model = keras.Sequential()\n# Adds a densely-connected layer with 64 units to the model:\nmodel.add(keras.layers.Dense(64, activation=&#39;relu&#39;))\n# Add another:\nmodel.add(keras.layers.Dense(64, activation=&#39;relu&#39;))\n# Add a softmax layer with 10 output units:\nmodel.add(keras.layers.Dense(10, activation=&#39;softmax&#39;))</code></pre><pre><code># Create a sigmoid layer:\nlayers.Dense(64, activation=&#39;sigmoid&#39;)\n# Or:\nlayers.Dense(64, activation=tf.sigmoid)\n\n# A linear layer with L1 regularization of factor 0.01 applied to the kernel matrix:\nlayers.Dense(64, kernel_regularizer=keras.regularizers.l1(0.01))\n# A linear layer with L2 regularization of factor 0.01 applied to the bias vector:\nlayers.Dense(64, bias_regularizer=keras.regularizers.l2(0.01))\n\n# A linear layer with a kernel initialized to a random orthogonal matrix:\nlayers.Dense(64, kernel_initializer=&#39;orthogonal&#39;)\n# A linear layer with a bias vector initialized to 2.0s:\nlayers.Dense(64, bias_initializer=keras.initializers.constant(2.0))</code></pre><ul> <li>在 compile 中配置训练方法 model.compile(optimizer = &quot;优化器&quot;, loss = &quot;损失函数&quot;, metrics = &quot;评测指标&quot;) </li> </ul> <pre><code>optimizer 可选:\n&#39;sdg&#39; or tf.keras.optimizers.SDG(lr = &quot;学习率&quot;, momentum = &quot;动量参数&quot;)\n&#39;adagrad&#39; or tf.keras.optimizers.Adagrad(lr = &quot;学习率&quot;)\n&#39;adadelta&#39; or tf.keras.optimizers.Adadelta(lr = &quot;学习率&quot;)\n&#39;adam&#39; or tf.teras.optimizers.Adam(lr = &quot;学习率&quot;, beta_1 = 0.9, beta_2 = 0.999)\n\nloss 可选: \n&#39;mse&#39; or tf.keras.losses.MeanSquaredError()\n[稀疏分类交叉熵](https://tensorflow.google.cn/versions/r2.0/api_docs/python/tf/keras/losses/SparseCategoricalCrossentropy) &#39;sparse_categorical_corossentropy&#39; or tf.keras.losses.SparseCategoricalCorossentropy(from_logits=False, reduction=losses_utils.ReductionV2.AUTO,\n    name=&#39;sparse_categorical_crossentropy&#39;) \nform_logits 表示是否不经概率分布 输出 （即softmax）\n\nmetrics 可选: \n&#39;accuracy&#39; 准确率 y_ 和 y 都是 数值 y_ = [1] y = [1]\n&#39;categorical_accuracy&#39; y_ 和 y 都是 独热码形式（即 概率分布） 如 y_ = [0,1,0] y = [0.1, 0.8, 0.1]\n&#39;sparse_categorical_accuracy&#39; y_ 是 数值 y 是独热码（概率分布），如 y_ = [1] y = [0.1, 0.8, 0.1]\n</code></pre><pre><code># Configure a model for mean-squared error regression.\n  model.compile(optimizer=tf.train.AdamOptimizer(0.01),\n                loss=&#39;mse&#39;,       # mean squared error\n                metrics=[&#39;mae&#39;])  # mean absolute error\n\n# Configure a model for categorical classification.\nmodel.compile(optimizer=tf.train.RMSPropOptimizer(0.01),\n              loss=keras.losses.categorical_crossentropy,\n              metrics=[keras.metrics.categorical_accuracy])</code></pre><ul> <li>model.fit 训练数据</li> </ul> <pre><code>model.fit(训练集的输入特征, 训练集的标签, batch_size=, epoches=, validation_data=(测试集的输入特征, 测试集的标签), validation_split=从训练集划分多少比例给测试集, validation_freq=多少次epoch测试一次)</code></pre><pre><code>epochs：训练多少轮。（小批量）\nbatch_size：当传递NumPy数据时，模型将数据分成较小的批次，并在训练期间迭代这些批次。 此整数指定每个批次的大小。 请注意，如果样本总数不能被批量大小整除，则最后一批可能会更小。\nvalidation_data：在对模型进行原型设计时，您希望轻松监控其在某些验证数据上的性能。 传递这个参数 - 输入和标签的元组 - 允许模型在每个epoch的末尾以传递数据的推理模式显示损失和度量。</code></pre><pre><code>import numpy as np\n\ndata = np.random.random((1000, 32))\nlabels = np.random.random((1000, 10))\n\nval_data = np.random.random((100, 32))\nval_labels = np.random.random((100, 10))\n\nmodel.fit(data, labels, epochs=10, batch_size=32,\n          validation_data=(val_data, val_labels))</code></pre>"},function(e,n){e.exports="<p>var toTree = (datasource) =&gt; { const _datasource = [...datasource] _datasource.map((v, i, a) =&gt; { if (v.parentId) { const cursor = _datasource.findIndex(_v =&gt; _v.id === v.parentId)</p> <pre><code>  if (cursor !== -1) {\n    _datasource[cursor].children = [...(_datasource[cursor].children || []), v]\n  }\n}\n\nreturn v</code></pre><p> })</p> <p> return _datasource.filter(v =&gt; !v.parentId) }</p> <p>data = [{ id: 1, name: &#39;1&#39;, }, { id: 2, name: &#39;1-1&#39;, parentId: 1 }, { id: 3, name: &#39;1-1-1&#39;, parentId: 2 }, { id: 4, name: &#39;1-2&#39;, parentId: 1 }, { id: 5, name: &#39;1-2-2&#39;, parentId: 4 }, { id: 6, name: &#39;1-1-1-1&#39;, parentId: 3 }, { id: 7, name: &#39;2&#39;, }]</p> <p>toTree(data)</p> "},function(e,n){e.exports="<p>处理 词 为 数组</p> <pre><code>var isAnagram = (s, t) =&gt; {\n  if (s.length !== t.length) return false\n\n  const dealStr = str =&gt; {\n    return str.split(&#39;&#39;).reduce((pre, v) =&gt; {\n      if (pre[v]) {\n        pre[v] +=1\n      } else {\n        pre[v] = 1\n      }\n\n      return pre\n    }, {})\n  }\n\n  sObj = dealStr(s)\n  tObj = dealStr(t)\n\n  sKeyArray = Object.keys(sObj)\n  tKeyArray = Object.keys(tObj)\n\n  if (sKeyArray.length !== tKeyArray.length) return false\n\n  return !sKeyArray.some(v =&gt; {\n    return sObj[v] !== tObj[v]\n  })\n}\ns=&quot;anagram&quot;, t=&quot;nagaram&quot;\nisAnagram(s, t)</code></pre>"},function(e,n){e.exports="<p>const maxSubArray = (nums: num[]) =&gt; { let max = 0</p> <p> nums.reduce((pre, v) =&gt; { if (pre &gt; 0) { pre = pre + v } else { pre = v }</p> <pre><code>max = Math.max(pre, max)\n\nreturn pre</code></pre><p> }, 0) }</p> "},function(e,n){e.exports="<h4 id=两数之和>两数之和</h4> <p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p> <p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p> <p>eg: 给定 nums = [2, 7, 11, 15], target = 9</p> <p>因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]</p> <pre><code class=language-javascript>var nums = [2, 7, 11, 15]\nvar target = 18\n\nvar result_of_number = (_nums, _target) =&gt; {\n  if (!Array.isArray(_nums)) {\n    throw(&#39;_nums 不合法&#39;)\n  }\n\n  if (typeof _target !== &#39;number&#39;) {\n    throw(&#39;target 不合法&#39;)\n  }\n\n  var coordinate = []\n\n  _nums.some((v, i) =&gt; {\n    var rest = _target - v \n    var index = _nums.indexOf(rest)\n\n    if (index &gt; -1) {\n      coordinate[0] = i\n      coordinate[1] = index\n    }\n\n    return index &gt; -1\n  })\n\n  return coordinate\n}\n\nresult_of_number(nums, target)</code></pre> <pre><code class=language-python>nums = [2, 7, 11, 15]\ntarget = 26\n\ndef result_of_number(_nums, _target):\n  coordinate = []\n  cur_index = 0\n\n  for num in _nums[cur_index:]:\n    rest = _target - num\n\n    try:\n      _index = _nums[cur_index:].index(rest)\n      coordinate.append(cur_index)\n      coordinate.append(cur_index + _index)\n      break \n    except:\n      cur_index += 1\n\n  return coordinate\n\nprint(result_of_number(nums, target))</code></pre> "},function(e,n){e.exports="<h4 id=两数相加>两数相加</h4> <p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p> <p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p> <p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p> <p>eg: 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807</p> <pre><code class=language-javascript>/**\n * Definition for singly-linked list.\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nfunction ListNode(val) {\n  this.val = val;\n  this.next = null;\n}\n\nvar l1_2 = new ListNode(2)\nvar l1_4 = new ListNode(4)\nvar l1_3 = new ListNode(3)\n\nl1_2.next = l1_4\nl1_4.next = l1_3\n\nvar l2_5 = new ListNode(5)\nvar l2_6 = new ListNode(6)\nvar l2_4 = new ListNode(4)\n\nl2_5.next = l2_6\nl2_6.next = l2_4\n\nvar addTwoNumbers = function(l1, l2) {\n  var result = new ListNode(0)\n\n  var node = result\n\n  var _l1 = l1\n  var _l2 = l2\n\n  while(_l1 &amp;&amp; _l2) {\n    var sum = node.val + _l1.val + _l2.val\n\n    if (sum &gt;= 10) {\n      node.val = sum % 10\n    } else {\n      node.val = sum\n    }\n\n    _l1 = _l1.next\n    _l2 = _l2.next\n\n    if (!_l1) node.next = _l2\n    if (!_l2) node.next = _l1\n\n    if (_l1 &amp;&amp; _l2) node.next = new ListNode(sum &gt;= 10 ? 1 : 0)\n\n    node = node.next\n  }\n\n  return result\n};\n\naddTwoNumbers(l1_2, l2_5)</code></pre> <pre><code class=language-python># Definition for singly-linked list.\nclass ListNode:\n  def __init__(self, x):\n    self.val = x\n    self.next = None\n\nl1_2 = ListNode(2)\nl1_4 = ListNode(4)\nl1_3 = ListNode(3)\n\nl1_2.next = l1_4\nl1_4.next = l1_3\n\nl2_5 = ListNode(5)\nl2_6 = ListNode(6)\nl2_4 = ListNode(4)\n\nl2_5.next = l2_6\nl2_6.next = l2_4\n\nprint(l1_2.val, l1_2.next.val, l1_2.next.next.val)\nprint(l2_5.val, l2_5.next.val, l2_5.next.next.val)\n\nclass Solution:\n  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:\n    result = ListNode(0)\n    node = result \n    _l1 = l1\n    _l2 = l2\n\n    while _l1 and _l2 :\n      sum = node.val + _l1.val + _l2.val\n\n      if sum &gt;= 10:\n        node.val = sum % 10\n      else:\n        node.val = sum\n\n      _l1 = _l1.next\n      _l2 = _l2.next\n\n      if not _l1:\n        node.next = l2\n\n      if not _l2:\n        node.next = l1\n\n      if _l1 and _l2:\n        node.next = ListNode(1 if sum &gt;= 10 else  0)\n\n      node = node.next\n\n    return result\n\naddTwoNumbers = Solution().addTwoNumbers(l1_2, l2_5)\n\nprint(addTwoNumbers.val, addTwoNumbers.next.val, addTwoNumbers.next.next.val)</code></pre> "},function(e,n){e.exports="<h4 id=两数相加>两数相加</h4> <p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p> <p>eg: 输入: &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</p> <p>输入: &quot;bbbbb&quot; 输出: 1 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</p> <p>输入: &quot;pwwkew&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。   请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</p> <pre><code class=language-javascript>/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n  var sArray = s.split(&#39;&#39;)\n  var max = 0\n  sArray.reduce((pre, v) =&gt; {\n    var index = pre.indexOf(v)\n\n    if (index &gt; -1) {\n      pre = pre.slice(index + 1)\n    } \n\n    pre.push(v)\n    max = pre.length &gt; max ? pre.length : max\n\n    return pre\n  }, [])\n\n  return max\n};\n\nlengthOfLongestSubstring(&#39;abcabcbb&#39;)</code></pre> <pre><code class=language-python># Definition for singly-linked list.\nclass Solution:\n  def lengthOfLongestSubstring(self, s: str) -&gt; int:\n    list = []\n    max = 0\n    for index in range(s.__len__()):\n      cur_s = s[index]\n      try:\n        list = list[list.index(cur_s) + 1:]\n      except:\n        pass\n      list.append(cur_s)\n      max = len(list) if len(list) &gt; max else max\n\n      print(list)\n    return max\n\nlengthOfLongestSubstring = Solution().lengthOfLongestSubstring(&#39;asfgt&#39;)\n\nprint(lengthOfLongestSubstring)</code></pre> "},function(e,n){e.exports="<h4 id=寻找两个正序数组的中位数>寻找两个正序数组的中位数</h4> <p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p> <p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p> <p>你可以假设 nums1 和 nums2 不会同时为空。</p> <p>eg: nums1 = [1, 3] nums2 = [2]</p> <p>则中位数是 2.0</p> <p>nums1 = [1, 2] nums2 = [3, 4]</p> <p>则中位数是 (2 + 3)/2 = 2.5</p> <pre><code class=language-javascript>/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function(nums1, nums2) {\n  // 判断奇偶\n  var odd = (nums1.length + nums2.length) % 2 !== 0\n  var index = 0\n  var _list = []\n\n  for (const key in nums2) {\n    while(nums2[key] &gt; nums1[index]) {\n      _list.push(nums1[index])\n      index++\n    }\n\n    _list.push(nums2[key])\n\n    // 判断 nums2 结束 nums1 有 余项\n    if (key == nums2.length - 1) {\n      if (index &lt; nums1.length) {\n        _list = _list.concat(nums1.slice(index))\n        break\n      }\n    }\n  }\n\n  console.log(_list)\n\n  var half = parseInt(_list.length / 2)\n\n  return odd ? _list[half] : (_list[half] + _list[half - 1]) / 2\n};\n\nconsole.log(findMedianSortedArrays([1, 2, 3, 3, 8], [1, 2, 7, 9]))</code></pre> <pre><code class=language-python>class Solution:\n  def findMedianSortedArrays(self, nums1: list, nums2: list) -&gt; float:\n    odd = (nums1.__len__() + nums2.__len__()) % 2 != 0\n    _index = 0\n    _list = []\n\n    for index, num in enumerate(nums2):\n      try:\n        while(num &gt; nums1[_index]):\n          _list.append(nums1[_index])\n          _index+=1\n\n        _list.append(num)\n\n        # 最后一轮 \n        if index == nums2.__len__() - 1:\n          if _index &lt; nums1.__len__():\n            _list.extend(nums1[_index:])\n\n      except:\n        _list.extend(nums2[index:])\n        break\n\n    print(_list)\n\n    half = int(_list.__len__() / 2)\n\n    return _list[half] if odd else (_list[half] + _list[half - 1]) / 2\n\nfindMedianSortedArrays = Solution().findMedianSortedArrays([1, 2,4,7, 9, 10], [ 8, 11])\n\nprint(findMedianSortedArrays)</code></pre> "},function(e,n){e.exports="<h4 id=最长回文子串>最长回文子串</h4> <p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p> <p>eg: 输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。</p> <p>输入: &quot;cbbd&quot; 输出: &quot;bb&quot;</p> <pre><code class=language-javascript>/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n  var max = 0\n  var mid = parseInt(s.length / 2)\n\n  s.split(&#39;&#39;).map((v, index) =&gt; {\n    // 判断 是前半部分 还是 后半部分\n    var range = index &gt; mid ? s.length - index : index \n\n    let pre // 前部分\n    let after // 后部分\n    let length // 字符串长度\n\n    for (let i = range;i &gt;= 0 ;i -- ) {\n      // 中间 字母对称\n\n      var outLeft = index - i &lt; 0\n      var outRight = index + 1 + i &gt; s.length\n\n      if (!outLeft &amp;&amp; !outRight) {\n        pre = s.slice(index - i, index)\n        after = s.slice(index + 1, index + 1 + i)\n\n        if (pre &amp;&amp; after &amp;&amp; pre === after.split(&#39;&#39;).reverse().join(&#39;&#39;)) {\n          length = pre.length * 2 + 1\n          max = length &gt; max ? length : max\n        }\n      }  \n    }\n\n    // 镜像\n    for (let i = range;i &gt;= 0 ;i -- ) {\n      var outLeft = index - i &lt; 0\n      var outRight = index + 2 + i &gt; s.length\n\n      if (!outLeft &amp;&amp; !outRight) {\n        pre = s.slice(index - i, index + 1)\n        after = s.slice(index + 1, index + 2 + i)\n\n        if (pre &amp;&amp; after &amp;&amp; pre === after.split(&#39;&#39;).reverse().join(&#39;&#39;)) {\n          length = pre.length * 2\n          max = length &gt; max ? length : max\n        }\n      }\n    }\n  })\n\n  return max\n};\nconsole.log(longestPalindrome(&#39;xxxxxixxxxx&#39;))</code></pre> <pre><code class=language-python>class Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n\nlongestPalindrome = Solution().longestPalindrome(&#39;abcbc&#39;)\n\nprint(longestPalindrome)</code></pre> "}])]);