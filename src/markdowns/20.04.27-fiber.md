### Fiber
背景
我们知道 React 是通过递归的方式来渲染组件的，在 V16 版本之前的版本里，当一个状态发生变更时，react 会从当前组件开始，依次递归调用所有的子组件生命周期钩子，而且这个过程是同步执行的且无法中断的，一旦有很深很深的组件嵌套，就会造成严重的页面卡顿，影响用户体验。

React 在V16版本之前的版本里引入了 Fiber 这样一个东西，它的英文涵义为纤维，在计算机领域它排在在进程和线程的后面，虽然 React 的 Fiber 和计算机调度里的概念不一样，但是可以方便对比理解，我们大概可以想象到 Fiber 可能是一个比线程还短的时间片段。

#### Fiber 到底做了什么事
Fiber 把当前需要执行的任务分成一个个微任务，安排优先级，然后依次处理，每过一段时间（非常短，毫秒级）就会暂停当前的任务，查看有没有优先级较高的任务，然后暂停（也可能会完全放弃）掉之前的执行结果，跳出到下一个微任务。同时 Fiber 还做了一些优化，可以保持住之前运行的结果以到达复用目的。

#### 举个潜水员的例子

我们可以把调度当成一个潜水员在海底寻宝，v16 之前是通过组件递归的方式进行寻宝，从父组件开始一层一层深入到最里面的子组件

而替换成了 Fiber 后，海底变成的狭缝（简单理解为递归变成了遍历），潜水员会每隔一小段时间浮出水面，看看有没有其他寻宝任务。注意此时没有寻到宝藏的话，那么之前潜水的时间就浪费了。就这样潜水员会一直下潜和冒泡


#### 时间分片
原理： 在每一帧的中会先执行 macrotasks 任务 -> 再执行 UI rendering -> 最后有剩余时间执行 Idle 回调


react 16 之前，react 通过虚拟 dom 更新是同步的，一旦有更新就会一直执行到更新完毕, 如果更新很复杂就会一直占用浏览器主线程，这时候浏览器本身的动画和用户输入操作就会出现卡顿或没响应。

react 16 后，采用时间片的方式解决更新卡顿的问题。
给每个 react 更新任务一个过期时间 timeout，维护一个 react 更新队列
通过 requestAnimationFrame 找到每一帧的开始时间，再计算出下一帧的开始时间
把优先级最高的 react 更新任务推入 event loop 的 tasks queue 中
每次 event loop 开始 react 更新的 tasks 时都会检查这个任务是否到期 timeout 了，只有 timeout 时才会执行
react 更新任务会先进入 renderRoot 渲染阶段更新 fiberTree 上的内容，再进行 completeRoot 提交阶段更改 dom 的最终结果。
react 更新任务 didTimeout 过期时执行 renderRoot ，这个渲染阶段哪怕时间很长也最大限度的保证了浏览器高优先级别的动画和用户输入的流畅运行

调度时通过 requestAnimationFrame api 在浏览器每次重绘前做想做的事
requestAnimationFrame 回调 animationTick 在浏览器动画执行前 执行
他在 animationTick 中确定了下一帧结束的时间点
因为不知道 react 更新需要多少时间，所以没有在 animationTick 中判断 timeRemaining() 当前帧剩余时间来执行 react 更新
而是把用于 react 更新的 flushWork 通过 postMessage 推入下个 tick 事件队列中的 idleTick 回调，也就是 macrotasks
在 window.addEventListener(‘message’, idleTick, false); 的 idleTick 中一直拖到 frameDeadline - currentTime <= 0 当前帧完全过期时
才把 didTimeout = true, 再 执行 prevScheduledCallback(didTimeout); - flushWork(didTimout) 这次 react 更新。
这次 macrotasks 的 flushWork 先于 requestAnimationFrame 执行
这时 flushWork 就算更新时间超过当前帧剩余时间借用了下一帧的时间，也是最大限度的保证了浏览器动画的流畅性和优先级。
