#### 正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

```
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
```
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

eg:
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。

输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false

```javascript
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  var matchArr = p.split('').reduce((pre, val) => {
    if (val === '*') {
      pre[pre.length - 1] = pre[pre.length - 1] + '*'
    } else {
      pre.push(val)
    }
    return pre
  }, [])

  var check = element => {
    for (let index = 0; index < matchArr.length; index++) {
      const match = matchArr[index];
      var cur_word = match[0]
      var isRepeat = (match[1] === '*')
  
      if (cur_word === '.') {
        cur_word = element
      }

      if (cur_word === element) {
        if (!isRepeat) {
          matchArr.shift()
        }

        return true
      } else {
        matchArr.shift()
        return check(element)
      }
    }

    return false
  }

  for (let index = 0; index < s.length; index++) {
    const element = s[index]
    var result = check(element)

    if (!result) {
      return false
    }
  }

  if (matchArr.length > 0) {
    // 判断是否是 x*
    return matchArr.some(v => v.length === 1)
  }

  return true
}

s = "mississippi"
p = "mis*is*p*."

// s = "aabb"
// p = "c*c*a*bb"

// s = "ab"
// p = ".*"

// s = "aa"
// p = "a.*.*.*"

console.log(isMatch(s, p))
```

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:


isMatch1 = Solution().isMatch(121)
isMatch2 = Solution().isMatch(-121)
isMatch3 = Solution().isMatch(10)

print(isMatch1)
print(isMatch2)
print(isMatch3)
```
