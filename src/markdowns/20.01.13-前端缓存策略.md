### 前端缓存策略

缓存的类型

浏览器有如下常见的几个字段：

expires: 设置缓存过期的时间
private: 客户端可以缓存
public: 客户端和代理服务器都可缓存
max-age=xxx: 缓存的内容将在 xxx 秒后失效
no-cache: 需要使用对比缓存来验证缓存数据
no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发
last-modified: 内容上次被修改的时间
Etag: 文件的特殊标识

> 缓存方法可以分为强制缓存与协商缓存。

#### 强制缓存

> 从字面理解，强制缓存的方式简单粗暴，给`cache`设置了`过期时间`，超过这个时间之后cache过期需要重新请求。上述字段中的`expires`与`cache-control中的max-age`都属于强制缓存

> 强制缓存优先级高于协商缓存

##### expires

> expires给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求。

`Expires: Fri, 04 Jan 2019 12:00:00 GMT`

这个方法简单直接，直接设定一个绝对的时间 (当前时间+缓存时间)。但是也存在隐患，例如浏览器当前时间是可以进行更改的，更改之后expires设置的绝对时间相对不准确，cache可能会出现长久不过期或者很快就过期的情况。

##### cache-control: max-age

>为了解决expires存在的问题，Http1.1版本中提出了cache-control: max-age，该字段与expires的缓存思路相同，都是设置了一个过期时间，不同的是max-age设置的是相对缓存时间开始往后多久，因此不存在受日期不准确情况的影响。

但是强制缓存存在一个问题，该缓存方式优先级高，如果在过期时间内缓存的资源在服务器上更新了，客服端不能及时获取最新的资源。

#### 协商缓存

协商缓存解决了无法及时获取更新资源的问题。以下两组字段，都可以对资源做标识，由服务器做分析，如果未进行更新，那返回304状态码，从缓存中读取资源，否则重新请求资源

##### last-modify

> last-modify告知了客户端上次修改该资源的时间，

`Last-Modified: Wed, 02 Jan 2019 03:06:03 GMT`

浏览器将这个值记录在`if-modify-since`中(浏览器自动记录了该字段信息)，下一次请求相同资源时，与服务器返回的`last-modify`进行比对，如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。

last-modify以秒为单位进行更新，如果小于该单位高频进行更新的话，不适合采用该方法。

##### ETag

> ETag是对资源的特殊标识

`Etag: W/"e563df87b65299122770e0a84ada084f"`

请求该资源成功之后，将返回的ETag存入if-none-match字段中(浏览器自动记录了该字段信息)，同样在请求资源时传递给服务器，服务器查询该编码对应的资源有无更新，无更新返回304状态，更新返回200并重新请求。