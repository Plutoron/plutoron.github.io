### 神仙源码

[源地址](https://zhuanlan.zhihu.com/p/108289604)

#### 实现一个new操作符

new 做了什么

1.创建一个空的简单JavaScript对象（即{}）；
2.链接该对象（即设置该对象的构造函数）到另一个对象；
3.将步骤（1）新创建的对象作为this的上下文；
4.如果该函数没有返回对象，则返回this。（是引用类型则返回对象，值类型返回this）

```
function create(context, ...args) {
  // 创建一个空对象
  this.obj = {}

  // 将空对象指向构造函数的原型链
  Object.setPrototypeOf(this.obj, context.prototype)

  // 将obj绑定到构造函数上，便可以直接访问构造函数中的属性，即this.obj.context(args)
  const result = context.apply(this.obj, args)

  // 如果返回的result是一个对象则返回
  // new 方法失效，否则返回obj
  return result instanceof Object ? result : this.obj
}
```

#### 实现一个Array.isArray

利用Object.prototype.toString

```
Array.myIsArray = function(e) {
  return Object.prototype.toString.call(Object(e)) === '[object Array]'
}
```

#### 实现一个Object.create()方法

```
const create = e => {
  const F = function() {}
  F.prototype = F
  return new F()
}
```

#### 实现一个EventEmitter 类

```
class Event {
  constructor() {
    this.subscriber = {}
  }

  on(type, callback) {
    const _curSubscriber = this.subscriber[type] || []

    // 判断有木有
    if (_curSubscriber.includes(callback)) {
      return this
    }

    this.subscriber[type] = [..._curSubscriber, callback]

    return this
  }

  off(type, callback) {
    const _curSubscriber = this.subscriber[type]
    
    if (callback) {
      _curSubscriber && (this.subscriber[type] = _curSubscriber.filter(item => item !== callback))
    } else {
      _curSubscriber && (delete this.subscriber[type])
    }

    return this
  }

  emit(type, ...param) {
    const _curSubscriber = this.subscriber[type] || []

    _curSubscriber.forEach(callback => {
        callback(param)
    })

    return this
  }

  once(type, callback) {
    const _onceFun = () => {
      callback.apply(this)
      this.off(type, _onceFun)
    }

    this.on(type, _onceFun)
  }

  removeAll() {
    this.subscriber = {}

    return this
  }
}
```

#### 实现一个Array.prototype.reduce

`Array.prototype.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])`

```
Array.prototype.myReduce = function(callback, initialValue) {
  let result = initialValue !== undefined ? initialValue : this[0]

  for (let i = initialValue !== undefined ? 0 : 1; i < this.length; i++) {
    result = callback(result, this[i], i, this)
  }

  return result
}
```

#### 实现一个Call || Apply

call 分两步 改变函数this 指向，然后 执行函数

```
Function.prototype.myCall = function(context) {
  context = context || window

  context.fn = this

  // 获取其余参数
  const [source, ...rest] = [...arguments]

  const result = context.fn(...rest)

  delete context.fn
  return result
}
```

myApply的参数形式为(obj,[arg1,arg2,arg3])
所以myApply的第二个参数为[arg1,arg2,arg3]

```
Function.prototype.myApply = function(context) {
  context = context || window

  context.fn = this

  const rest = [...arguments][1]

  const result = context.fn(...rest)

  delete context.fn
  return result
}
```

```
Function.prototype.myBind = function() {
  const _this = this

  const [source, ...rest] = [...arguments]

  // 创建一个函数,并执行合并之后的参数
  const fn = function() {
    const _rest = [...arguments]

    // 区分 引用类型和值类型
    const _source = this instanceof fn ? this : source

    _this.apply(_source, rest.concat(_rest))
  }

  //添加原函数所有的prototype的值
  fn.prototype = Object.create(this.prototype)

  return fn
}
```

#### JS函数柯里化

```
function curry(fn) {
  // 第一遍运行length是函数fn一共需要的参数个数，以后是剩余所需要的参数个数
  const length = fn.length

  return function judge() {
    const _args = [...arguments]

    if (_args.length < length) {
      return function() {
        return judge(..._args, ...arguments)
      }
    }

    // 参数收集 完成，执行该函数
    return fn(..._args)
  }
}

let curryFun = curry((a, b, c) => console.log(a, b, c))

curryFun(1)(2)(3)
```

```
function add() {
  let _args = [...arguments]

  let action = function() {
    _args = [..._args, ...arguments]

    // 收集参数完毕
    if (arguments.length === 0) {
      return _args.reduce((pre, val) => {
        return pre + val
      }, 0)
    }

    return action
  }

  return action
}

add(1)(2)(3)()
add(1, 2, 3)(4)()
```

```
function add() {
  let _args = [...arguments]

  let action = function() {
    _args = [..._args, ...arguments]

    return action
  }

  action.toString = function () {
    return _args.reduce((pre, val) => {
      return pre + val
    }, 0)
  }

  return action
}

add(1)(2)(3) // f 6
+add(1)(2)(3) // 6
add(1, 2, 3)(4)
```

#### 手写防抖（Debounce） 和 节流（Throttle）

防抖 间隔时间内，重复触发，更新触发间隔

```
function debounce(fun, wait) {
  let timeout
  return function() {
    const _this = this
    const args = arguments

    if (timeout) {
      clearTimeout(timeout)
    }

    timeout = setTimeout(() => {
      fun.apply(_this, args)

      timeout = undefined
    }, wait)
  }
}

```

节流 间隔时间内，重重触发无效果,只触发一次

```
function throttle(fun, delay) {
  let preTime = Date.now()
  return function() {
    const curTime = Date.now() 

    if (curTime - preTime > delay) {
      fun.apply(this, arguments)

      preTime = curTime
    }
  }
}

```

#### 深拷贝 深度优先

```
function deepClone(source) {
   // typeof null 也是 object
  if (source !== null && typeof source === 'object') {
    const _target = Array.isArray(source) ? [] : {}

    for (const i in source) {
      if (typeof source === 'object') {
        _target[i] = deepClone(source[i])
      } else {
        _target[i] = source[i]
      }
    }

    return _target
  } else {
    return source
  }
}
```

#### 实现一个Array.prototype.flat() 

```
Array.prototype.myFlat = function(depth = 1) {
  return this.reduce((pre, value) => {
    if (Array.isArray(value)) {
      // 不循环
      if (!Number(depth) || Number(depth) === 0) {
        pre.push(value)
      } else {
        pre.push(value.myFlat(depth - 1))
      }
    }

    return pre 
  }, [])
}
```

#### 实现一个双向绑定

Vue 2.x的Object.defineProperty版本

```
// 数据
const data = {
  text: 'test'
}

const input = document.getElementById('input')
const span = document.getElementById('span')

// 数据劫持
Object.defineProperty(data, 'text', {
  // 数据变化 —> 修改视图
  set(newVal) {
    input.value = newVal;
    span.innerHTML = newVal;
  }
})

// 视图更改 --> 数据变化
input.addEventListener('keyup', function(e) {
  data.text = e.target.value;
});
```

```
// 数据
const data = {
  text: 'default'
};
const input = document.getElementById('input');
const span = document.getElementById('span');
// 数据劫持
const handler = {
  set(target, key, value) {
    target[key] = value;
    // 数据变化 —> 修改视图
    input.value = value;
    span.innerHTML = value;
    return value;
  }
};
const proxy = new Proxy(data, handler);

// 视图更改 --> 数据变化
input.addEventListener('keyup', function(e) {
  proxy.text = e.target.value;
});
```

