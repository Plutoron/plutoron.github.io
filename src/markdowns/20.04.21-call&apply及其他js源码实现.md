### 神仙源码

[源地址](https://zhuanlan.zhihu.com/p/108289604)

#### 实现一个new操作符

new 做了什么

1.创建一个空的简单JavaScript对象（即{}）；
2.链接该对象（即设置该对象的构造函数）到另一个对象；
3.将步骤（1）新创建的对象作为this的上下文；
4.如果该函数没有返回对象，则返回this。（是引用类型则返回对象，值类型返回this）

```
function create(context, ...args) {
  // 创建一个空对象
  this.obj = {}

  // 将空对象指向构造函数的原型链
  Object.setPrototypeOf(this.obj, context.prototype)

  // 将obj绑定到构造函数上，便可以直接访问构造函数中的属性，即this.obj.context(args)
  const result = context.apply(this.obj, args)

  // 如果返回的result是一个对象则返回
  // new 方法失效，否则返回obj
  return result instanceof Object ? result : this.obj
}
```
```
function _new(source) {
  let obj = {}

  obj.__proto__ = source.prototype

  return source.call(obj)
}
```

#### 实现一个 instanceof

```
function instanceof(obj, fn) {
  const proto = fn.prototype

  let target = obj.__proto__

  while(target) {
    if (target === proto) return true

    target = target.__proto__
  }

  return false
}
```

#### 实现一个Array.isArray

利用Object.prototype.toString

```
Array.myIsArray = function(e) {
  return Object.prototype.toString.call(Object(e)) === '[object Array]'
}
```

```
Array.myIsArray = function(e) {
  return Array.prototype.isPrototypeOf(e)
}
```

#### 实现一个Object.create()方法

```
const create = e => {
  const F = function() {}
  F.prototype = F
  return new F()
}
```

#### 实现一个EventEmitter 类

```
class Event {
  constructor() {
    this.subscriber = {}
  }

  on(type, callback) {
    const _curSubscriber = this.subscriber[type] || []

    // 判断有木有
    if (_curSubscriber.includes(callback)) {
      return this
    }

    this.subscriber[type] = [..._curSubscriber, callback]

    return this
  }

  off(type, callback) {
    const _curSubscriber = this.subscriber[type]
    
    if (callback) {
      _curSubscriber && (this.subscriber[type] = _curSubscriber.filter(item => item !== callback))
    } else {
      _curSubscriber && (delete this.subscriber[type])
    }

    return this
  }

  emit(type, ...param) {
    const _curSubscriber = this.subscriber[type] || []

    _curSubscriber.forEach(callback => {
        callback(param)
    })

    return this
  }

  once(type, callback) {
    const _onceFun = () => {
      callback.apply(this)
      this.off(type, _onceFun)
    }

    this.on(type, _onceFun)
  }

  removeAll() {
    this.subscriber = {}

    return this
  }
}
```

#### 实现一个Array.prototype.reduce

`Array.prototype.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])`

```
Array.prototype.myReduce = function(callback, initialValue) {
  let result = initialValue !== undefined ? initialValue : this[0]

  for (let i = initialValue !== undefined ? 0 : 1; i < this.length; i++) {
    result = callback(result, this[i], i, this)
  }

  return result
}
```

#### 实现一个Call || Apply

call 分两步 改变函数this 指向，然后 执行函数

```
Function.prototype.myCall = function(context) {
  context = context || window

  context.fn = this

  // 获取其余参数
  const [source, ...rest] = [...arguments]

  const result = context.fn(...rest)

  delete context.fn
  return result
}
```

myApply的参数形式为(obj,[arg1,arg2,arg3])
所以myApply的第二个参数为[arg1,arg2,arg3]

```
Function.prototype.myApply = function(context) {
  context = context || window

  context.fn = this

  const rest = [...arguments][1]

  const result = context.fn(...rest)

  delete context.fn
  return result
}
```

```
Function.prototype.myBind = function() {
  const _this = this

  const [source, ...rest] = [...arguments]

  // 创建一个函数,并执行合并之后的参数
  const fn = function() {
    const _rest = [...arguments]

    // 区分 引用类型和值类型
    const _source = this instanceof fn ? this : source

    _this.apply(_source, rest.concat(_rest))
  }

  //添加原函数所有的prototype的值
  fn.prototype = Object.create(this.prototype)

  return fn
}
```

#### JS函数柯里化

```
function curry(fn) {
  // 第一遍运行length是函数fn一共需要的参数个数，以后是剩余所需要的参数个数
  const length = fn.length

  return function judge() {
    const _args = [...arguments]

    if (_args.length < length) {
      return function() {
        return judge(..._args, ...arguments)
      }
    }

    // 参数收集 完成，执行该函数
    return fn(..._args)
  }
}

let curryFun = curry((a, b, c) => console.log(a, b, c))

curryFun(1)(2)(3)
```

```
function add() {
  let _args = [...arguments]

  let action = function() {
    _args = [..._args, ...arguments]

    // 收集参数完毕
    if (arguments.length === 0) {
      return _args.reduce((pre, val) => {
        return pre + val
      }, 0)
    }

    return action
  }

  return action
}

add(1)(2)(3)()
add(1, 2, 3)(4)()
```

```
function add() {
  let _args = [...arguments]

  let action = function() {
    _args = [..._args, ...arguments]

    return action
  }

  action.toString = function () {
    return _args.reduce((pre, val) => {
      return pre + val
    }, 0)
  }

  return action
}

add(1)(2)(3) // f 6
+add(1)(2)(3) // 6
add(1, 2, 3)(4)
```

#### 手写防抖（Debounce） 和 节流（Throttle）

防抖 间隔时间内，重复触发，更新触发间隔

```
function debounce(fun, wait) {
  let timeout
  return function() {
    const _this = this
    const args = arguments
    
    clearTimeout(timeout)

    timeout = setTimeout(() => {
      fun.apply(_this, args)
    }, wait)
  }
}

```

节流 间隔时间内，重重触发无效果,只触发一次

```
function throttle(fun, delay) {
  let preTime = Date.now()
  return function() {
    const curTime = Date.now() 

    if (curTime - preTime > delay) {
      fun.apply(this, arguments)

      preTime = curTime
    }
  }
}

```

#### 深拷贝 深度优先

```
function deepClone(source) {
   // typeof null 也是 object
  if (source !== null && typeof source === 'object') {
    const _target = Array.isArray(source) ? [] : {}

    for (const i in source) {
      if (typeof source === 'object') {
        _target[i] = deepClone(source[i])
      } else {
        _target[i] = source[i]
      }
    }

    return _target
  } else {
    return source
  }
}
```

#### 实现一个双向绑定

Vue 2.x的Object.defineProperty版本

```
// 数据
const data = {
  text: 'test'
}

const input = document.getElementById('input')
const span = document.getElementById('span')

// 数据劫持
Object.defineProperty(data, 'text', {
  // 数据变化 —> 修改视图
  set(newVal) {
    input.value = newVal;
    span.innerHTML = newVal;
  }
})

// 视图更改 --> 数据变化
input.addEventListener('keyup', function(e) {
  data.text = e.target.value;
});
```

```
// 数据
const data = {
  text: 'default'
};
const input = document.getElementById('input');
const span = document.getElementById('span');
// 数据劫持
const handler = {
  set(target, key, value) {
    target[key] = value;
    // 数据变化 —> 修改视图
    input.value = value;
    span.innerHTML = value;
    return value;
  }
};
const proxy = new Proxy(data, handler);

// 视图更改 --> 数据变化
input.addEventListener('keyup', function(e) {
  proxy.text = e.target.value;
});
```

#### 实现 _.get

```
function get(target, ...rest) {
  var getKeys = str => {
    var isIndex = str => str.startsWith('[')
    var matchIndex = /\[([0-9]*)\]/
    var matchKey = /^[a-z0-9]+/i
  
    var arr = []
    while(str.length !== 0) {
      function replacer(match, ...rest) {
        var _key = isIndex(str) ? rest[0] : match
        arr.push(_key)
        return ''
      }
  
      if (isIndex(str)) {
        str = str.replace(matchIndex, replacer);
        console.log('isIndex', str)
      } else {
        str = str.replace(matchKey, replacer);
      }
    }

    return arr
  }

  return rest.map(v => {
    return v.split('.').map(_v => getKeys(_v)).flat().reduce((pre, value) => {
      return pre[value]
    }, target)
  })
}

var object = { 'a': [{ 'b': { 'c': 3 } }, ['d']] };
 
console.log(get(object, 'a[0].b.c', 'a[0].b', 'a[1][0]'))
```

#### 打平一个数组
```
function flat(target, depth = 1) {
  if (depth <= 0) {
    return target.slice()
  }

  return target.reduce((pre, value) => {
    if (Array.isArray(value)) {
      pre = pre.concat(flat(value, depth - 1))
    } else {
      pre.push(value)
    }

    return pre
  }, [])
}

var arr1 = [1,2,3,[1,2,3,4, [2,3,4]]];

console.log(flat(arr1, 1))
```

#### ES6 ES5 作用域

```
function O(age){
  this.age = age
}

let o = new O(1)
let age = 3
O.prototype.age = 2

setTimeout(function() {
  age = 4

  O(5)

  console.log(O(5), age, window.age) // undefined 4 5
})
```

#### Promise

```
const PENDING = "pending"
const FULFILLED = "fulfilled"
const REJECTED = "rejected"

function Promise(fn) {
  let that = this

  this.status = 'pending'
  this.value = undefined
  this.reason = undefined

  that.fulfilledCallback = []; //成功状态回调函数
  that.rejectedCallback = [];  //失败状态回调函数

  function resolve(value) {
    that.value = value
    this.status = FULFILLED
  }

  function reject(reason) {
    that.reason = reason
    this.status = REJECTED
  }

  try {
    fn(resolve, reject)
  } catch (e) {
    reject(e)
  }
}


class Promise {
  constructor(executor) {
    this.status = 'pending'
    this.value = undefined
    this.reason = undefined

    this.onResolvedCallbacks = []
    this.onRejectedCallbacks = []

    const resolve = value => {
      if (this.state === 'pending') {
        this.state = 'fulfilled'
        this.value = value 
        this.onResolvedCallbacks.map(fn => fn())
      }
    }

    const reject = reason => {
      if (this.state === 'pending') {
        this.state = 'rejected'
        this.reason = reason
        this.onRejectedCallbacks.map(fn => fn())
      }
    }

    try {
      executor(resolve, reject)
    } catch (e) {
      reject(e)
    }
  }

  then(onFulfilled, onRejected) {
    if (this.state === 'fulfilled') {
      onFulfilled(this.value)
    }

    if (this.state === 'rejected') {
      onRejected(this.value)
    }

    if (this.state === 'pending') {
      this.onResolvedCallbacks.push(onFulfilled)
      this.onRejectedCallbacks.push(onRejected)
    }
  }
}
```