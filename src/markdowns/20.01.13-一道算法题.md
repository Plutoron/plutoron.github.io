给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。

你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 k*k 个积分。

当你将所有盒子都去掉之后，求你能获得的最大积分和。
示例 1：
输入:
[1, 3, 2, 2, 2, 3, 4, 3, 1]
输出:
23
解释:
[1, 3, 2, 2, 2, 3, 4, 3, 1]
----> [1, 3, 3, 4, 3, 1] (3*3=9 分)
----> [1, 3, 3, 3, 1] (1*1=1 分)
----> [1, 1] (3*3=9 分)
----> [] (2*2=4 分)
提示：盒子的总数 n 不会超过 100。

```
// reduce 处理 数组 每一项，将 一个数据 拆分为 n 个 段
// 每一段 存储 value length index
// 拆分时 分为两个数组 
// 一个数组 按索引 存储 
// 一个数据 按长度 存储

// 第一轮 要判断所有 长度不为一 并且 左右邻居相等 的 项 并清除
// 第二轮 要判断所有 长度不为一 并且 左右邻居不相等 的 项 并清除

const source = [1, 3, 2, 2, 2, 3, 4, 3, 1]

const formated = source.reduce((pre, value, index, array) => {
    // 第一轮第一个
    if (index === 0) {
        pre.push({
            value: value,
            length: 1,
            index: pre.length,
        })
    } else {
        // 后面 的 和上一个相等
        if (value === array[index - 1]) {
            pre[0].length = pre[0].length + 1
        } else {
            pre.push({
                value,
                length: 1,
                index: pre.length,
            })
        }
    }

    return pre
}, [])

const sortByLengthArray = formated.sort((a, b) => {return a.length - b.length})


const getMaxPoint = () => {
     const 
}

```