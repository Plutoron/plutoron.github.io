#### 寻找两个正序数组的中位数

给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。

请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

eg:
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
  // 判断奇偶
  var odd = (nums1.length + nums2.length) % 2 !== 0
  var index = 0
  var _list = []

  for (const key in nums2) {
    while(nums2[key] > nums1[index]) {
      _list.push(nums1[index])
      index++
    }

    _list.push(nums2[key])

    // 判断 nums2 结束 nums1 有 余项
    if (key == nums2.length - 1) {
      if (index < nums1.length) {
        _list = _list.concat(nums1.slice(index))
        break
      }
    }
  }

  console.log(_list)

  var half = parseInt(_list.length / 2)

  return odd ? _list[half] : (_list[half] + _list[half - 1]) / 2
};

console.log(findMedianSortedArrays([1, 2, 3, 3, 8], [1, 2, 7, 9]))
```

```python
class Solution:
  def findMedianSortedArrays(self, nums1: list, nums2: list) -> float:
    odd = (nums1.__len__() + nums2.__len__()) % 2 != 0
    _index = 0
    _list = []

    for index, num in enumerate(nums2):
      try:
        while(num > nums1[_index]):
          _list.append(nums1[_index])
          _index+=1

        _list.append(num)
        
        # 最后一轮 
        if index == nums2.__len__() - 1:
          if _index < nums1.__len__():
            _list.extend(nums1[_index:])
       
      except:
        _list.extend(nums2[index:])
        break

    print(_list)

    half = int(_list.__len__() / 2)

    return _list[half] if odd else (_list[half] + _list[half - 1]) / 2

findMedianSortedArrays = Solution().findMedianSortedArrays([1, 2,4,7, 9, 10], [ 8, 11])

print(findMedianSortedArrays)
```
