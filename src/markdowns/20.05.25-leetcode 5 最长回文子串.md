#### 最长回文子串

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

eg:
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

输入: "cbbd"
输出: "bb"

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  var max = 0
  var mid = parseInt(s.length / 2)

  s.split('').map((v, index) => {
    // 判断 是前半部分 还是 后半部分
    var range = index > mid ? s.length - index : index 
    
    let pre // 前部分
    let after // 后部分
    let length // 字符串长度

    for (let i = range;i >= 0 ;i -- ) {
      // 中间 字母对称

      var outLeft = index - i < 0
      var outRight = index + 1 + i > s.length

      if (!outLeft && !outRight) {
        pre = s.slice(index - i, index)
        after = s.slice(index + 1, index + 1 + i)
  
        if (pre && after && pre === after.split('').reverse().join('')) {
          length = pre.length * 2 + 1
          max = length > max ? length : max
        }
      }  
    }

    // 镜像
    for (let i = range;i >= 0 ;i -- ) {
      var outLeft = index - i < 0
      var outRight = index + 2 + i > s.length
      
      if (!outLeft && !outRight) {
        pre = s.slice(index - i, index + 1)
        after = s.slice(index + 1, index + 2 + i)
  
        if (pre && after && pre === after.split('').reverse().join('')) {
          length = pre.length * 2
          max = length > max ? length : max
        }
      }
    }
  })

  return max
};
console.log(longestPalindrome('xxxxxixxxxx'))
```

```python
class Solution:
  def longestPalindrome(self, s: str) -> str:
    max = 0
    mid = int(s.__len__() / 2)

    for index, v in enumerate(s):
      _range = index if index < mid else s.__len__() - mid
      pre = ''
      after = ''
      length = 0

      # 中间对称
      for cursor in range(index):
        cursor = cursor + 1
  
        outRight = index - cursor < 0
        outLeft = index + 1 + cursor > s.__len__()

        if (not outLeft) and (not outRight):
          pre = s[(index - cursor):index]
          after = s[(index + 1): (index + 1 + cursor)]

          if pre and after:
            _val = list(after)
            _val.reverse()
            reverse_after = ''.join(str(i) for i in _val)

            if pre == reverse_after:
              max = max if max > pre.__len__() * 2 + 1 else pre.__len__() * 2 + 1

      # 镜像对称
      for cursor in range(index):
        cursor = cursor + 1
  
        outRight = index - cursor < 0
        outLeft = index + 2 + cursor > s.__len__()

        if (not outLeft) and (not outRight):
          pre = s[(index - cursor):(index + 1)]
          after = s[(index + 1): (index + 2 + cursor)]

          if pre and after:
            _val = list(after)
            _val.reverse()
            reverse_after = ''.join(str(i) for i in _val)

            if pre == reverse_after:
              max = max if max > pre.__len__() * 2 else pre.__len__() * 2

    return max    

longestPalindrome = Solution().longestPalindrome('abcdfccc')

print(longestPalindrome)
```
