#### 请求限流

```
class limitPromise {
  constructor({
    max,
    fn
  }) {
    // 最大并发数
    this.max = max
    // 当前任务队列
    this.quene = {}
    // 自定义请求
    this.fn = fn
    // 等待进程
    this.restUrls = []
  }
  getCurQueneNum() {
    return Object.keys(this.quene).length
  }
  init(urls) {
    for (let index = 0; index < urls.length; index++) {
      const url = urls[index];

      this.add(url)
    }
  }
  // 添加 进程到队列
  updateQuene(url) {
    this.fn(url).finally(() => {
      delete this.quene[url]
      const nextUrl = this.restUrls[0]
      if (nextUrl) {
        this.quene[nextUrl] = this.updateQuene(nextUrl)
        this.restUrls.shift()
      }
    }) 
  }
  add(url) {
    if (this.getCurQueneNum() < this.max) {
      if (!this.quene[url]) {
        this.quene[url] = this.updateQuene(url)
      } else {
        console.log('正在请求')
      }
    } else {
      this.restUrls.push(url)
    }
  }
}

// test
const URLS = [
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7'
];
// 自定义请求函数
var requestFn = url => {
  return new Promise(resolve => {
    setTimeout(_ => {
      resolve(`任务 ${url} 完成`);
    }, 1000)
  }).then(res => {
    console.log('外部逻辑 ', res);
  })
}

const pool = new limitPromise({max: 3, fn: requestFn}); // 并发数为3
pool.init(URLS);
```

