### 二叉树 遍历

#### 什么是先序/中序/后序

所谓前序、中序、后序，不过是根的顺序，即也可以称为前根遍历、中根遍历、后根遍历

前序 对于二叉树中的任意一个节点，先打印该节点，然后是它的左子树，最后右子树

`根 -> 左 -> 右`

中序 对于二叉树中的任意一个节点，先打印它的左子树，然后是该节点，最后右子树

`左 -> 根 -> 右`

后序 对于二叉树中的任意一个节点，先打印它的左子树，然后是右子树，最后该节点

`左 -> 右 -> 根`


```
树的图例          

       1
         \
           2
         /
       3 
       
输入：root = [1, null, 2, 3]

先序输出：[1, 2, 3]   
中序输出：[1, 3, 2]  
后序输出：[3, 2, 1]
```

#### 递归实现

前序 `根 -> 左 -> 右`
```
const preOrderTraversalRecursion = (root) => {
  const result = []

  const preOrderTraversal = (node) => {
    if (node === null) return

    result.push(node.val)

    preOrderTraversal(node.left)
    preOrderTraversal(node.right)
  }

  preOrderTraversal(root)

  return result
}

const preOrderTraversalIteration = (root) => {
  const result = []

  const stack = []

  if (root !== null) stack.push(root)

  while (stack.length > 0) {
    const curNode = stack.pop()

    result.push(curNode.val)

    if (curNode.right !== null) {
      stack.push(curNode.right)
    }

    if (curNode.left !== null) {
      stack.push(curNode.left)
    }
  }

  return result
}
```

中序 `左 -> 根 -> 右`
```
const midOrderTraversalRecursion = (root) => {
  const result = []
  
  const midOrderTraveral = (node) => {
    if (node !== null) {
      midOrderTraveral(node.left)

      result.push(node.val)

      midOrderTraveral(node.right)
    }
  }

  midOrderTraveral(root)

  return result
}

const midOrderTraversalIteration = (root) => {
  const result = []
  const stack = []
  let curNode = null

  if (root !== null) curNode = root

  while (stack.length > 0 || curNode !== null) {
    while (curNode !== null) {
      stack.push(curNode)
      curNode = curNode.left
    }

    if (stack.length > 0) {
      curNode = stack.pop()
      result.push(curNode.val)
      curNode = curNode.right
    }
  }

  return result
}
```

后序 `左 -> 右 -> 根`
``` 
const afterOrderTraversalRecursion = (root) => {
  const result = []

  const afterOrderTraversal = (node) => {
    if (node !== null) {
      afterOrderTraversal(node.left)
      afterOrderTraversal(node.right)
      result.push(node.val)
    }
  }

  afterOrderTraversal(root)

  return result 
} 

const afterOrderTraversalRecursion = (root) => {
  const result = []
  const stack = []

  if (root !== null) stack.push(root)

  while (stack.length > 0) {
    const curNode = stack.pop()

    stack.unshift(curNode.val)

    if (curNode.left !== null) stack.push(curNode.left)
    if (curNode.right !== null) stack.push(curNode.right)
  } 

  return result
}
```