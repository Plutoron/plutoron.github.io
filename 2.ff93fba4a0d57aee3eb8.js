(window.webpackJsonp=window.webpackJsonp||[]).push([[2],Array(28).concat([function(n,e,t){var o={"./19.10.12-useEffect 的坑.md":29,"./19.10.12-webpack4新手向.md":30,"./19.10.12-新的开始.md":31,"./19.10.15-webpack4+react+babel 踩坑.md":32,"./19.10.18-搭建自己的Github Page.md":33,"./19.10.24-webpack打包优化.md":34,"./19.10.26-瞎搞webhook.md":35,"./19.10.30-记一道面试题.md":38,"./19.10.31-HTTP协议.md":39,"./19.10.31-HTTP状态码.md":43,"./19.11.01-ES6 Iterator.md":44,"./19.11.05-What is this.md":45,"./19.11.07-事件循环（Event Loop）.md":46,"./19.11.08-webpack 原理.md":49,"./19.11.09-TCP 和 UDP.md":51,"./19.11.18-认识了新伙伴-Svelte.md":52,"./19.11.21-mobx 和 redux.md":53,"./19.11.26-redux和koa中间件.md":54,"./19.11.26-十进制转换其他进制.md":55,"./19.11.27-微信小程序原理.md":56,"./19.11.29-使用vw进行移动端自适应布局.md":61,"./19.12.02-history.listen()-后台侧边栏根据路由选中.md":62,"./19.12.02-mac chorme跨域.md":63,"./19.12.06-小程序开发遇到的深坑.md":64,"./19.12.07-数据更新和管理tips.md":65,"./19.12.13-贴一段hooks的antd列表页.md":66,"./19.12.16-require.context.md":67,"./19.12.16-多页的一个坑-html模版引入的文件勿忘commom.md":68,"./19.12.16-设计思路-去中心化.md":69,"./19.12.17-利用require.context批量引入图片资源输出成组件.md":70,"./19.12.18-利用Suspense和lazy模块懒加载.md":71,"./19.12.18-还记得它吗.md":72,"./19.12.19-接口 定义返回结果原则.md":73,"./19.12.24-node 简易本地静态服务.md":74,"./19.12.25-antd script 标签引入 定制样式.md":75,"./19.12.26-object.defineProperty.md":76,"./20.01.06-react-router switch存在的意义.md":77,"./20.01.07-null 和 undefined的区别.md":78,"./20.01.09-写一套serverless—undo.md":79,"./20.01.11-Vue 和 mobx 观察者模式.md":80,"./20.01.11-getSearchParam.md":83,"./20.01.13-一道算法题-undo.md":84,"./20.01.13-前端缓存策略.md":85,"./20.01.14-gitlab cli.yml.md":86,"./20.01.14-一段shell.md":87,"./20.01.14-钉钉模块的插件化开发思路 或 小程序的思路.md":88,"./20.01.16-一个图片全屏预览组件.md":89,"./20.01.16-试试一个文本标注的本地场景.md":90,"./20.01.17-URL.createObjectURL.md":92,"./20.01.17-webpack plugin入门.md":93,"./20.01.17-匹配 dom 标签的正则.md":94,"./20.01.19-npm 包 一些注意记录.md":95};function r(n){var e=a(n);return t(e)}function a(n){if(t.o(o,n))return o[n];var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}r.keys=function(){return Object.keys(o)},r.resolve=a,(n.exports=r).id=28},function(n,e){n.exports='<h3 id="坑啊">坑啊</h3>\n<p>wrong</p>\n<pre><code>useEffect(async () =&gt; {\n  setTableLoading(true)\n  try {\n    const res = await io.getUserList({\n      activityId,\n      phone,\n      userName,\n      currentPage,\n      pageSize,\n    })\n\n    setTotal(res.count)\n    setList(res.data)\n    setTableLoading(false)\n  } catch (e) {\n    setTableLoading(false)\n    message.error(e.message)\n  }\n}, [query])</code></pre><p>right</p>\n<pre><code>useEffect(() =&gt; {\n  const fetchData = async () =&gt; {\n    setTableLoading(true)\n    try {\n      const res = await io.getUserList({\n        activityId,\n        phone,\n        userName,\n        currentPage,\n        pageSize,\n      })\n\n      setTotal(res.count)\n      setList(res.data)\n      setTableLoading(false)\n    } catch (e) {\n      setTableLoading(false)\n      message.error(e.message)\n    }\n  }\n\n  fetchData()\n}, [query])\n</code></pre>'},function(n,e){n.exports='<h3 id="webpack4新手向">webpack4新手向</h3>\n<p>写自己配置webpack的经历 </p>\n<p>参考资料：<br><a href="https://www.webpackjs.com/guides/">webpack 中文文档 指南栏</a><br><a href="https://webpack.js.org/guides/">webpack 英文文档 指南栏</a><br>ps: 感觉 英文 Configuration 栏 看着舒服 知道 是哪个配置项</p>\n<h4 id="初始化webpack">初始化webpack</h4>\n<p>安装 webpack &amp; webpack-cli</p>\n<pre><code>npm init -y\nnpm install webpack webpack-cli --save-dev</code></pre><p>添加webpack配置文件 webpack.config.js</p>\n<pre><code>const path = require(&#39;path&#39;);\n\nmodule.exports = {\n  entry: &#39;./src/index.js&#39;,\n  output: {\n    filename: &#39;bundle.js&#39;,\n    path: path.resolve(__dirname, &#39;dist&#39;)\n  }\n}</code></pre><p>package.json 的 scripts 中添加 build 命令</p>\n<pre><code>&quot;build&quot;: &quot;webpack --mode production&quot;,</code></pre><p>这样 我们就可以 <em>npm run build</em> 打包我们的代码了</p>\n<p>根据上面的配置:<br>入口文件： <em>src/index.js</em><br>打包后的目录： <em>dist</em>  </p>\n<pre><code>  |- package.json\n+ |- webpack.config.js\n  |- /dist\n    |- bundle.js\n  |- /src\n    |- index.js</code></pre><h4 id="添加html模版">添加html模版</h4>\n<p>我们打包生成的js文件需要配合html文件，可以生成web入口。<br>我们可以通过 webpack的plugins配置项，添加 html-webpack-plugin，生成一个html入口模版</p>\n<p>安装html-webpack-plugin依赖</p>\n<pre><code>npm i html-webpack-plugin -D</code></pre><p>修改webpack.config.js </p>\n<pre><code>const htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = {\n  ...\n  plugins: [\n    new HtmlwebpackPlugin({\n      title: &#39;title 参数 生成的html模板的title。但指定了 template 后 该参数无效！！！&#39;\n      filename: &#39;xxxx.html&#39;,   // build后html文件名\n      template: &#39;./src/index.html&#39;  // 入口html文件模板，不指定的话，会默认生成 一个html模版\n    })\n  ]\n}</code></pre><p><em>基本模版内容仅供参考</em>\n需放到上面配置的template对应目录</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n  &lt;title&gt;React App&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>打包后的文件结构</p>\n<pre><code>  |- package.json\n  |- webpack.config.js\n  |- /dist\n    |- bundle.js\n  + |- xxx.html\n  |- /src\n    |- index.js</code></pre><h4 id="可以开始开发react了">可以开始开发React了</h4>\n<p>webpack-dev-server登场</p>\n<pre><code>npm i webpack-dev-server --save-dev</code></pre><p>安装React &amp; React-Dom</p>\n<pre><code>npm i react react-dom -S</code></pre><p>package.json 的 scripts 中添加 start 命令</p>\n<pre><code>&quot;start&quot;: &quot;webpack-dev-server --mode development --open --hot&quot;,</code></pre><p>这样 我们就可以 <em>npm start</em> 本地开发我们的项目了</p>\n<p>在src下 添加以下文件看看效果吧\n<em>src/index.js</em></p>\n<pre><code>import React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nimport App from &#39;./components/app&#39;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;app&#39;))</code></pre><p><em>src/components/app.js</em></p>\n<pre><code>import React, { Component } from &#39;react&#39;\n\nexport default class App extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        test \n      &lt;/div&gt;\n    )\n  }\n}</code></pre><h4 id="添加-babel">添加 babel</h4>\n<p>安装依赖 <em>@babel/core @babel/preset-env @babel/preset-react</em></p>\n<pre><code>npm install --save-dev @babel/core @babel/preset-env @bable/preset-react</code></pre><p>添加 .babelrc 配置文件</p>\n<pre><code>// targets, useBuiltIns 等选项用于编译出兼容目标环境的代码\n// 其中 useBuiltIns 如果设为 &quot;usage&quot;\n// Babel 会根据实际代码中使用的 ES6/ES7 代码，以及与你指定的 targets，按需引入对应的 polyfill\n// 而无需在代码中直接引入 import &#39;@babel/polyfill&#39;，避免输出的包过大，同时又可以放心使用各种新语法特性。\n// 还需要指定corejs 版本\n{\n  &quot;presets&quot;: [\n    [\n      &quot;@babel/preset-env&quot;,\n      {\n        {\n          &quot;modules&quot;: false,\n          &quot;targets&quot;: {\n            &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]\n          },\n          &quot;useBuiltIns&quot;: &quot;usage&quot;,\n          &quot;corejs&quot;: 2\n        } \n      }\n    ],\n    &quot;@babel/preset-react&quot;\n  ]\n}</code></pre>'},function(n,e){n.exports='<h4 id="新的开始">新的开始</h4>\n<ul>\n<li>拥抱变化</li>\n<li>满怀信心</li>\n<li>HAPPY </li>\n</ul>\n'},function(n,e){n.exports='<h3 id="webpack4reactbabel-踩坑">webpack4+react+babel 踩坑</h3>\n<p>自己踩坑的经历 </p>\n<h4 id="react-router">react-router</h4>\n<p>issue: 定义的 BrowserRouter, 路由刷新 报 cannot get /xxx</p>\n<p>answer:  </p>\n<ul>\n<li><p>本地webpack 配置 </p>\n<pre><code>devServer: {\n  historyApiFallback: true,\n}</code></pre><p><em>只适合开发环境中进行配置</em>\n<em>线上环境需要服务器支持</em></p>\n</li>\n<li><p>BrowserRouter 改为 HashRouter   </p>\n<ol>\n<li>路由会有 # 号，影响美观</li>\n<li>不能使用服务器渲染</li>\n</ol>\n</li>\n</ul>\n<h4 id="babel7">Babel7</h4>\n<p>issue: Support for the experimental syntax &#39;classProperties&#39; isn&#39;t currently enabled </p>\n<p>answer: </p>\n<pre><code>npm i -D @babel/plugin-proposal-class-properties\n\n\n配置.babelrc \n\n{ \n  &quot;plugins&quot;: [ \n    [\n      &quot;@babel/plugin-proposal-class-properties&quot;, \n      { &quot;loose&quot;: true }\n    ] \n  ] \n}   \n</code></pre><p>issue: babel 在每个文件都插入了辅助代码，使代码体积过大！</p>\n<p>answer: </p>\n<pre><code>你必须执行 \nnpm install @babel/plugin-transform-runtime --save-dev 来把它包含到你的项目中，也要使用 \nnpm install babel-runtime --save-dev 把 babel-runtime 安装为一个依赖\n\n修改.babelrc\n\n&quot;plugins&quot;: [\n  ...\n  &quot;@babel/transform-runtime&quot;,\n  ...\n]</code></pre><p>issue: this.setDynamic is not a function</p>\n<p>answer: </p>\n<pre><code>babel7-\nnpm install babel-plugin-transform-runtime --save-dev\n\nbabel7+ 插件 修改\nnpm install @babel/plugin-transform-runtime --save-dev</code></pre>'},function(n,e){n.exports='<h3 id="搭建自己的github-page">搭建自己的Github Page</h3>\n<p>有两种方式</p>\n<ul>\n<li><p>创建一个 username.github.io repo<br>创建一个 index.md / index.html\n路径 在  <code>https://username.github.io</code></p>\n</li>\n<li><p>创建一个 xxx repo<br>创建一个 index.md / index.html<br>setting 下 选择 github page 打开 page 功能\n路径 在  <code>https://username.github.io/xxx</code></p>\n</li>\n</ul>\n<blockquote>\n<p>master 分支下 默认 读取 index 文件 作为 根路由。</p>\n</blockquote>\n<blockquote>\n<p>Github Page 的路由规则 是 托管 master 根目录下的 xxx.md(html)，对应 <code>https://username.github.io/xxx</code>。 </p>\n</blockquote>\n<blockquote>\n<p>index除外，index文件默认根路由。</p>\n</blockquote>\n<h4 id="这样我们-就可以-将我们-通过脚手架-build-后的文件-托管到-git-查看效果了">这样我们 就可以 将我们 通过脚手架 build 后的文件 托管到 git 查看效果了</h4>\n<p>我们的 单页面应用 路由 建议使用 HashRouter，因为 BroswerRouter 有问题</p>\n<p>ps: 等着看看是否解决 和 如何解决</p>\n<h4 id="我的经验">我的经验</h4>\n<h5 id="stage-1-本着各各代码库-各司其职的原则">stage 1: 本着各各代码库 各司其职的原则</h5>\n<pre><code>step 1:\n\ngit clone https://github.com/xxx/xxx.github.io.git  \n初始化 我们的 Github Pages 的本地库  \n\nstep 2:\n\n新建另一个开发代码库   \n初始化 开发框架 开发完 npm run build 生成 dist 目录\n\nstep 3:\n\n将 dist 目录下 的 文件 复制到 Github Page 库下 更新</code></pre><p><em>我的心路历程@1</em>  </p>\n<blockquote>\n<p>init github-page-repo -&gt; init work-repo -&gt; work done -&gt; build -&gt; move dist to github-page-repo -&gt; update</p>\n</blockquote>\n<p>大写的心累</p>\n<h5 id="stage-2-聪明一点的我，把开发库改成了-github-page-库下的-开发分支">stage 2: 聪明一点的我，把开发库改成了 Github Page 库下的 开发分支</h5>\n<pre><code>step 1:\n\ngit clone https://github.com/xxx/xxx.github.io.git  \n初始化 我们的 Github Pages 的本地库  \n\nstep 2:\ngit checkout -b dev\n新建另一个开发分支 \n初始化 开发框架 开发完 npm run build 生成 dist 目录\n\nstep 3:\n\n将 dist 目录下 的 文件 复制到 master 分支 更新</code></pre><p><em>我的心路历程@2</em></p>\n<blockquote>\n<p>init github-page-repo -&gt; checkout dev-branch -&gt; work done -&gt; build -&gt; move dist to master -&gt; update</p>\n</blockquote>\n<p>虽然依旧心累但是 只维护 一个库 不用 切文件夹 了，但是要切分支</p>\n<p><em>我的心路历程@2.1</em></p>\n<p>干嘛不用个脚本！！！</p>\n<blockquote>\n<p>添加 deploy.sh 一键 ./deploy.sh 部署发布</p>\n</blockquote>\n<pre><code class="language-shell">npm run build\ngit checkout master\nrm -rf index.html\nrm -rf *.js\nrm -rf *.css\nmv dist/* ./\ngit add .\ngit commit -m &#39;commit message&#39;\ngit push origin master\ngit checkout dev</code></pre>\n<p>Because of Lan, I become stronger!!!</p>\n'},function(n,e){n.exports='<h3 id="webpack-配置打包优化">webpack 配置打包优化</h3>\n<h4 id="样式提取及压缩">样式提取及压缩</h4>\n<p><em>mini-css-extract-plugin</em> 将css文件提取成一个文件\n<em>optimize-css-assets-webpack-plugin</em> 压缩css文件</p>\n<pre><code>mini-css-extract-plugin 将css文件提取成一个文件\n\nconst MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;) // css 并合并成 文件\n\nmodule: {\n  rules: [\n    {\n      test: /\\.(le|c)ss$/,\n      use: [\n        // 添加 环境判断 变量 只有生产环境 使用 MiniCssExtractPlugin\n        isDEV ? &#39;style-loader&#39; : MiniCssExtractPlugin.loader,\n        &#39;css-loader&#39;, \n        { \n          loader: &#39;postcss-loader&#39;,\n          options: {\n            plugins: loader =&gt; [\n              require(&#39;autoprefixer&#39;)(), // CSS浏览器兼容 需要package.json 添加 对应的 browserslist,也有其他方式，自行搜索\n            ]\n          }\n        },\n        `less-loader?{&quot;sourceMap&quot;:true, &quot;modifyVars&quot;:${JSON.stringify(theme)}, &quot;javascriptEnabled&quot;: true}`,\n      ], // 注意排列顺序，执行顺序与排列顺序相反\n    },\n  ],\n}\n\nplugins: [\n  ...,\n  ...(isDEV ? \n    []\n    : [\n      new MiniCssExtractPlugin({\n        filename: &#39;[name].css&#39;,\n        // 将相关模块的 样式分离，生成不同的文件，按需加载 css下载变小，加快页面加载\n        chunkFilename: &#39;[name].[contenthash].css&#39; \n      }),\n    ]\n  ),\n  ...,\n],\n\noptimize-css-assets-webpack-plugin 压缩css文件\n\noptimization: {\n  minimizer: [\n    // 混淆 js\n    new UglifyJsPlugin({\n      uglifyOptions: {\n        compress: {\n          drop_console: true,\n        },\n        ecma: 5,\n      },\n      cache: true,\n      parallel: true,\n      sourceMap: true,\n    }),\n    // 压缩css\n    new OptimizeCSSAssetsPlugin({\n      assetNameRegExp: /\\.css$/g,\n      cssProcessorOptions: {\n        // const safeParser = require(&#39;postcss-safe-parser&#39;) 添加前缀的规则\n        parser: safeParser, \n        discardComments: {\n          removeAll: true,\n        },\n      },\n    }),\n  ],\n},</code></pre><h4 id="js模块打包拆分">js模块打包拆分</h4>\n<h5 id="commonjs-提取">common.js 提取</h5>\n<pre><code>optimization: {\n  splitChunks: {\n    cacheGroups: {\n      common: {\n        test: /[\\\\/]node_modules[\\\\/] || src\\//,\n        chunks: &#39;all&#39;,\n        name: &#39;common&#39;,\n        minSize: 0,\n        minChunks: 2,\n        priority: 10, //优先级\n        enforce: true,\n      },\n    },\n  },\n}</code></pre><h5 id="react、react-dom、react-router-dom-等公用模块-走cdn">react、react-dom、react-router-dom 等公用模块 走CDN</h5>\n<blockquote>\n<p>将我们用到的依赖 通过外部cdn的方式引入，打包时不打包，减少打包体积大小，将它们从package.json里面删掉</p>\n</blockquote>\n<pre><code>externals: {\n  react: &#39;React&#39;,\n  &#39;react-dom&#39;: &#39;ReactDOM&#39;,\n  &#39;react-router-dom&#39;: &#39;ReactRouterDOM&#39;,\n},\nplugins: [\n  ...,\n  new HtmlWebpackPlugin({\n    jsCdns: [\n      &#39;https://cdn.jsdelivr.net/npm/react@16.10.2/umd/react.production.min.js&#39;,\n      &#39;https://cdn.jsdelivr.net/npm/react-dom@16.10.2/umd/react-dom.production.min.js&#39;,\n      &#39;https://cdn.jsdelivr.net/npm/react-router-dom@5.1.2/umd/react-router-dom.min.js&#39;,\n    ],\n    template: &#39;./template/index.html&#39;,\n    minify: {\n      collapseWhitespace: true, // 折叠空白\n      removeComments: true, // 移除注释\n      removeAttributeQuotes: true // 移除属性的引号\n    }\n  }),\n  ...,\n],</code></pre><p><em>模版对应修改</em></p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n  &lt;title&gt;suyunlonsy&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n\n  &lt;% htmlWebpackPlugin.options.jsCdns.map(item =&gt; {{ %&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%= item %&gt;&quot;&gt;&lt;/script&gt;\n  &lt;% }}) %&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><h4 id="配置-resolve-优化-加载解析速度">配置 resolve 优化 加载解析速度</h4>\n<pre><code>resolve: {\n  alias: {\n    src: resolve(&#39;src&#39;),\n    common: resolve(&#39;src/common&#39;),\n    images: resolve(&#39;src/images&#39;),\n    markdowns: resolve(&#39;src/markdowns&#39;),\n    mods: resolve(&#39;src/components&#39;),\n  },\n  extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;css&#39;]\n},</code></pre>'},function(n,e,t){n.exports='<h4 id="瞎搞webhook">瞎搞webhook</h4>\n<blockquote>\n<p>Webhooks是GitHub提供的一个API。Webhooks可以在GitHub仓库(repositories)发生事件(比如提交代码,创建分支，发布版本)时，通知到其他服务器。Webhook实质上就是一个callback</p>\n</blockquote>\n<h5 id="在github中设置项目的webhook">在GitHub中设置项目的webhook</h5>\n<ol>\n<li><p>进入 GitHub 代码库，依次点击「Settings」、「Webhooks &amp; Services」、「Add Webhook」\n<img src="'+t(36)+'" alt="alt 仓库setting页"></p>\n</li>\n<li><p>填入对应的Webhook地址，即可完成配置\n<img src="'+t(37)+'" alt="alt 仓库setting页"></p>\n</li>\n</ol>\n<h5 id="神奇的工具">神奇的工具</h5>\n<p><a href="https://ngrok.com/">公网映射工具 ngrok</a></p>\n'},function(n,e,t){n.exports=t.p+"images/webhook-setting.jpg?3dff130d5bae83e8a8a3649650259cec"},function(n,e,t){n.exports=t.p+"images/webhook-config.jpeg?14a9fc8c5f84688f548f339d3d3e0f22"},function(n,e){n.exports='<pre><code>// 题目：\n// 以 provinces 为数据源，设计并实现区域选择组件 RegionSelect\n// 要求：确保 Demo 能够正常使用 RegionSelect\n// 具体包含：\n// 1. Demo 向 RegionSelect 传值能够正确渲染\n// 2. Demo 中的 handleRegionChange 能够正确输出\n// 3. 考虑 RegionSelect 组件的通用性\n\nimport React, { Component } from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\nimport &quot;antd/dist/antd.css&quot;;\nimport &quot;./index.css&quot;;\nimport { Select } from &quot;antd&quot;;\n\nconst { Option } = Select;\n\nconst provinces = [\n  {\n    name: &quot;浙江省&quot;,\n    code: 1,\n    cities: [\n      {\n        name: &quot;杭州市&quot;,\n        code: 11,\n        areas: [{ name: &quot;西湖区&quot;, code: 111 }, { name: &quot;余杭区&quot;, code: 112 }]\n      },\n      {\n        name: &quot;宁波市&quot;,\n        code: 12,\n        areas: [{ name: &quot;江北区&quot;, code: 121 }, { name: &quot;江东区&quot;, code: 122 }]\n      }\n    ]\n  },\n  {\n    name: &quot;广东省&quot;,\n    code: 2,\n    cities: [\n      {\n        name: &quot;广州市&quot;,\n        code: 21,\n        areas: [{ name: &quot;白云区&quot;, code: 211 }, { name: &quot;天河区&quot;, code: 212 }]\n      },\n      {\n        name: &quot;深圳市&quot;,\n        code: 22,\n        areas: [{ name: &quot;宝安区&quot;, code: 221 }, { name: &quot;南山区&quot;, code: 222 }]\n      }\n    ]\n  }\n];\n\n// 完善组件功能\nclass RegionSelect extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;Select /&gt;省\n        &lt;Select /&gt;市\n        &lt;Select /&gt;区\n      &lt;/div&gt;\n    );\n  }\n}\n\n// 确保 RegionSelect 在以下 Demo 中能够正常运行\nclass Demo extends Component {\n  state = {\n    value: [1, 11, 111]\n  };\n\n  handleRegionChange(value) {\n    console.log(value);\n  }\n\n  render() {\n    const { value } = this.state;\n    return &lt;RegionSelect value={value} /&gt;;\n  }\n}\n\nReactDOM.render(&lt;Demo /&gt;, document.getElementById(&quot;container&quot;));\n</code></pre><p><a href="http://suyunlongsy.github.io/#/region-select">自己写的组件</a></p>\n'},function(n,e,t){n.exports='<h2 id="http-协议">HTTP 协议</h2>\n<p><img src="'+t(40)+'" alt="alt 模拟流程图"></p>\n<h3 id="请求">请求</h3>\n<blockquote>\n<p>一个http请求由<em>请求行</em>，<em>请求头</em>，<em>空行</em>，<em>请求主体</em>组成</p>\n</blockquote>\n<p><img src="'+t(41)+'" alt="alt HTTP Request"></p>\n<h4 id="请求头中的请求方式（http11新增5种）：">请求头中的请求方式（http/1.1新增5种）：</h4>\n<ul>\n<li>GET 请求指定的页面信息，并返回实体主体</li>\n<li>HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li>\n<li>POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>\n<li>PUT 从客户端向服务器传送的数据取代指定的文档的内容。</li>\n<li>DELETE 请求服务器删除指定的页面。</li>\n</ul>\n<h3 id="响应">响应</h3>\n<blockquote>\n<p>一个http响应由<em>状态行</em>，<em>响应头</em>，<em>空行</em>，<em>响应主体</em>组成</p>\n</blockquote>\n<p><img src="'+t(42)+'" alt="alt HTTP Response"></p>\n<h4 id="响应头">响应头</h4>\n<ul>\n<li>Content-Disposition：附件只需要把文件名给过去就可以，这个名称就是下载时显示的文件名称</li>\n<li>content-type：文件类型</li>\n</ul>\n<h4 id="状态码">状态码</h4>\n<p><a href="https://suyunlongsy.github.io/#/detail/19.10.31-HTTP状态码.md">戳我查看</a></p>\n<h3 id="http工作原理">HTTP工作原理</h3>\n<ol>\n<li><p>客户端连接到Web服务器</p>\n<blockquote>\n<p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接\n（TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket））</p>\n</blockquote>\n</li>\n<li><p>发送HTTP请求</p>\n<blockquote>\n<p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>\n</blockquote>\n</li>\n<li><p>服务器接受请求并返回HTTP响应</p>\n<blockquote>\n<p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>\n</blockquote>\n</li>\n<li><p>释放连接TCP连接</p>\n<blockquote>\n<p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求</p>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p><a href="https://baike.baidu.com/item/TCP/33012?fr=aladdin#6">TCP工作方式</a></p>\n</blockquote>\n<ol start="5">\n<li>客户端浏览器解析HTML内容<blockquote>\n<p>客户端浏览器首先<em>解析状态行</em>，查看表明请求是否成功的<em>状态码</em>。然后解析每一个<em>响应头</em>，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id="在浏览器地址栏输入url按回车后经历的流程">在浏览器地址栏输入URL按回车后经历的流程</h3>\n<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p>\n<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p>\n<p>3、浏览器发出读取文件(URL中域名后面部分对应的文件)的HTTP 请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器;</p>\n<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p>\n<p>5、释放TCP连接;</p>\n<p>6、浏览器将该 html 文本并显示内容;</p>\n'},function(n,e,t){n.exports=t.p+"images/HTTP-simulated-interaction-diagram.png?3edcfede7fc5f342d2584c1e8e0f0712"},function(n,e,t){n.exports=t.p+"images/HTTP-Request.png?f88ce3073d2e3b2355863675eff509fe"},function(n,e,t){n.exports=t.p+"images/HTTP-Response.png?e201f2e2c0821a48b0d7e64f96342a10"},function(n,e){n.exports='<h4 id="http-状态码">HTTP 状态码</h4>\n<table>\n<thead>\n<tr>\n<th align="left"></th>\n<th align="left">类别</th>\n<th align="left">原因短语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align="left">1XX</td>\n<td align="left">Informational（信息性状态码）</td>\n<td align="left">接受的请求正在处理</td>\n</tr>\n<tr>\n<td align="left">2XX</td>\n<td align="left">Success（成功状态码）</td>\n<td align="left">请求正常处理完毕</td>\n</tr>\n<tr>\n<td align="left">3XX</td>\n<td align="left">Redirection（重定向状态码）</td>\n<td align="left">需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td align="left">4XX</td>\n<td align="left">Client Error（客户端错误状态码）</td>\n<td align="left">服务器无法处理请求</td>\n</tr>\n<tr>\n<td align="left">5XX</td>\n<td align="left">Server Error（服务器错误状态码）</td>\n<td align="left">服务器处理请求出错</td>\n</tr>\n</tbody></table>\n<ul>\n<li><em>2XX——表明请求被正常处理了</em></li>\n<li><em>3XX——表明浏览器需要执行某些特殊的处理以正确处理请求</em></li>\n<li><em>4XX——表明客户端是发生错误的原因所在</em></li>\n<li><em>5XX——服务器本身发生错误</em></li>\n</ul>\n<h4 id="2xx">2XX</h4>\n<pre><code>200 OK：请求已正常处理。</code></pre><h4 id="3xx">3XX</h4>\n<pre><code>301 Moved Permanently ：客户端对该资源进行了缓存，服务端返回空，客户端直接从缓存中读取对应资源。（响应头中包含了Last-Modified或ETag）\n302 Found：请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n304 Not Modified：客户端对该资源进行了缓存，服务端返回空，客户端直接从缓存中读取对应资源。（响应头中包含了Last-Modified或ETag）</code></pre><h5 id="301重定向和302重定向的区别">301重定向和302重定向的区别</h5>\n<pre><code>302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。\n\n而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。</code></pre><h4 id="4xx">4XX</h4>\n<pre><code>400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。\n\n401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。\n\n403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）\n\n404 Not Found：服务器上没有请求的资源。路径错误等。</code></pre><h4 id="5xx">5XX</h4>\n<pre><code>500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。\n\n503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求</code></pre>'},function(n,e){n.exports='<h2 id="iterator">Iterator</h2>\n<blockquote>\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\n</blockquote>\n<blockquote>\n<p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>\n</blockquote>\n<blockquote>\n<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。</p>\n</blockquote>\n<blockquote>\n<p>Iterator 的遍历过程是这样的。</p>\n</blockquote>\n<blockquote>\n<p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>\n</blockquote>\n<blockquote>\n<p>（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</p>\n</blockquote>\n<blockquote>\n<p>（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</p>\n</blockquote>\n<blockquote>\n<p>（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。</p>\n</blockquote>\n<blockquote>\n<p>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p>\n</blockquote>\n<pre><code>常见的具有Iterator接口的遍历器:\n　　Array\n　　Map\n　　Set\n　　String\n　　TypedArray\n　　函数的 arguments 对象\n　　NodeList 对象\n　　生成器</code></pre>'},function(n,e){n.exports='<h2 id="what-is-this">What is this</h2>\n<h4 id="普通函数中的this">普通函数中的this</h4>\n<p>普通函数，this的概念是：this是JavaScript的一个关键字，他是指函数执行过程中，自动生成的一个内部对象，是指当前的对象，只在当前函数内部使用。（this对象是在运行时基于<code>函数的执行环境</code>绑定的：在全局函数中，this指向的是window；当函数被作为<code>某个对象的方法</code>调用时，this就等于那个对象）。</p>\n<h4 id="箭头函数的this">箭头函数的this</h4>\n<p>箭头函数的this是在<code>定义函数</code>时绑定的，不是在执行过程中绑定的。简单的说，函数在定义时，this就继承了定义函数的对象。</p>\n<p>比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题</p>\n<h4 id="bind-call-apply">bind call apply</h4>\n<blockquote>\n<p>作用都是改变函数运行时上下文（this指向）而存在的</p>\n</blockquote>\n<p>区别</p>\n<ul>\n<li>接收的第一个参数都是要绑定的this 指向</li>\n<li>apply 的 第二个参数 是一个 参数数组，call和bind的第二个及之后的参数作为函数士参按顺序传入</li>\n<li>bind 不会立即调用，其他两个会立即调用</li>\n</ul>\n<h4 id="es6-简易实现">es6 简易实现</h4>\n<p>call</p>\n<pre><code>Function.prototype.call = function(context) {\n  const ctx = context || window\n\n  // 将当前被调用的方法定义在cxt.func上。（为了能以对象调用的形式绑定this）\n  ctx.func = this\n\n  // 获取实参\n  const args = Array.from(arguments).slice(1)\n\n  // 以对象调用的 形式 调用func，此时this指向ctx，也就是传入的需要绑定的this指向\n  const res = arguments.length &gt; 1 ? ctx.fun(...args) : ctx.fun()\n\n  // 删除该方法，不然会对传入的对象造成污染（添加该方法）\n  delete ctx.func\n\n  return res\n}</code></pre><p>apply</p>\n<pre><code>Function.prototype.apply = function(context) {\n  const ctx = context || window\n\n  ctx.func = this\n\n  const res = arguments[1] ? ctx.func(...arguments[1]) : ctx.func()\n\n  delete ctx.func\n\n  return res\n}</code></pre><p>bind</p>\n<pre><code>Function.prototype.bind = function(context) {\n  // 对context进行深拷贝，防止污染\n  const ctx = JSON.parse(JSON.stringify(context)) || window\n\n  // 将当前被调用的方法定义在cxt.func上。（为了能以对象调用的形式绑定this） \n  ctx.func = this\n\n  const args = Array.from(arguments).slice(1)\n\n  return function() {\n    // 这里注意一点的是需要对bind函数的实参和返回的的绑定函数的实参进行参数合并，调用时传入！\n    const allArgs = args.concat(Array.from(arguments))\n\n    // 以对象的方式调用func，此时this指向ctx，也就是传入的需要被绑定的this指向\n    return allArgs.length &gt; 0 ? ctx.func(...allArgs) : ctx.func()\n  } \n}</code></pre>'},function(n,e,t){n.exports='<h2 id="事件循环（event-loop）">事件循环（Event Loop）</h2>\n<blockquote>\n<p>Event Loop即事件循环，是解决javaScript单线程运行阻塞的一种机制。</p>\n</blockquote>\n<blockquote>\n<p>一个例子开胃</p>\n</blockquote>\n<pre><code>//请写出输出内容\nasync function async1() {\n    console.log(&#39;async1 start&#39;);\n    await async2();\n    console.log(&#39;async1 end&#39;);\n}\nasync function async2() {\n    console.log(&#39;async2&#39;);\n}\n\nconsole.log(&#39;script start&#39;);\n\nsetTimeout(function() {\n    console.log(&#39;setTimeout&#39;);\n}, 0)\n\nasync1();\n\nnew Promise(function(resolve) {\n    console.log(&#39;promise1&#39;);\n    resolve();\n}).then(function() {\n    console.log(&#39;promise2&#39;);\n});\nconsole.log(&#39;script end&#39;);\n\n\n/*\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n*/</code></pre><h3 id="一执行栈、事件队列和事件循环原理">一.执行栈、事件队列和事件循环原理</h3>\n<h4 id="eventloop的相关概念">EventLoop的相关概念</h4>\n<p>1、堆（Heap）\n堆表示一大块非结构化的内存区域，对象，数据被存放在堆中</p>\n<p>2、栈（Stack）\n栈在javascript中又称执行栈，调用栈，是一种后进先出的数组结构，\nJavascript 有一个 主线程（main thread）和 调用栈(或执行栈call-stack)，主线各所有的任务都会被放到调用栈等待主线程执行。\nJS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p>\n<p>3、队列（Queue）\n队列即任务队列Task Queue，是一种先进先出的一种数据结构。在队尾添加新元素，从队头移除元素。</p>\n<p>当javascript代码执行的时候会将不同的变量存于内存中的不同位置：<code>堆（heap）</code>和<code>栈（stack）</code>中来加以区分。其中，堆里存放着一些<code>对象</code>。而栈中则存放着一些<code>基础类型变量</code>以及对象的<code>指针</code>。 但是我们这里说的执行栈和上面这个栈的意义却有些不同。</p>\n<p>我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的<code>执行环境（context）</code>，又叫``执行上下文<code>。这个执行环境中存在着这个方法的</code>私有作用域<code>，</code>上层作用域的指向，方法的参数<code>，这个作用域中定义的</code>变量<code>以及这个作用域的</code>this对象`。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为<strong>执行栈</strong>。</p>\n<p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么<code>js会向执行栈中添加这个方法的执行环境</code>，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，<code>js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境</code>。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p>\n<p>一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p>\n<p>以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？前文提过，js的另一大特点是<code>非阻塞</code>，实现这一点的关键在于下面要说的这项机制——<strong>事件队列（Task Queue）</strong>。</p>\n<p>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。\n当这个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为<strong>事件队列（任务队列）</strong>。\n被放入事件队列不会立刻执行其回调，而是<code>等待当前执行栈中的所有任务都执行完毕</code>， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。\n如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p>\n<h4 id="同步任务和异步任务">同步任务和异步任务</h4>\n<p>javascript是单线程。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。\n于是js所有任务分为两种：同步任务，异步任务\n<strong>同步任务</strong>是调用立即得到结果的任务，同步任务在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p>\n<p><strong>异步任务</strong>是调用无法立即得到结果，需要额外的操作才能预期结果的任务，异步任务不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>\n<p>JS引擎遇到异步任务（DOM事件监听、网络请求、setTimeout计时器等），会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 事件触发线程 将异步对应的 回调函数 加入到消息队列中，消息队列中的回调函数等待被执行。</p>\n<p>具体来说，异步运行机制如下：</p>\n<p>（1）所有同步任务都在主线程上执行，形成一个[执行栈]</p>\n<p>（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</p>\n<p>（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>\n<p>（4）主线程不断重复上面的第三步。</p>\n<p><img src="'+t(47)+'" alt="alt event loop"></p>\n<h4 id="宏任务和微任务">宏任务和微任务</h4>\n<pre><code>console.log(&#39;script start&#39;)\n\nsetTimeout(function() {\n    console.log(&#39;timer over&#39;)\n}, 0)\n\nPromise.resolve().then(function() {\n    console.log(&#39;promise1&#39;)\n}).then(function() {\n    console.log(&#39;promise2&#39;)\n})\n\nconsole.log(&#39;script end&#39;)\n\n// script start\n// script end\n// promise1\n// promise2\n// timer over</code></pre><p>&quot;promise 1&quot; &quot;promise 2&quot; 在 &quot;timer over&quot; 之前打印了？\n这里有一个新概念：macrotask（宏任务） 和 microtask（微任务）。</p>\n<p>所有任务分为宏任务（macrotask ）和微任务（microtask ） 两种。\nMacroTask（宏任务）：* script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。</p>\n<p>MicroTask（微任务）：* Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver（具体使用方式查看这里）</p>\n<p>在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 宏任务 的队列中取出第一个任务，执行完毕后取出 微任务 队列中的所有任务顺序执行；之后再取 宏任务，周而复始，直至两个队列的任务都取完。</p>\n<p><img src="'+t(48)+'" alt="alt event loop"></p>\n<h4 id="总结">总结</h4>\n<p>浏览器中的事件循环机制较为简单，如果将主线程也看成一个宏任务的话，那么浏览器的事件循环可看作依次执行一下两点：</p>\n<ul>\n<li>从宏任务队列中取出一个宏任务执行</li>\n<li>清空微任务<pre><code>while(true) {\n  宏任务队列.shift()\n  微任务队列全部任务\n}</code></pre></li>\n</ul>\n<p>tips：</p>\n<ul>\n<li>宏任务队列和微任务队列都遵循先进先出的原则，先被加入队列的任务优先被取出执行</li>\n<li>Promise对象的resolve部分不是微任务，then 和 catch 部分才是<pre><code>setTimeout(function(){\nconsole.log(&#39;1&#39;)\n});\n</code></pre></li>\n</ul>\n<p>new Promise(function(resolve){\n  console.log(&#39;2&#39;);\n  resolve();\n}).then(function(){\n  console.log(&#39;3&#39;)\n});</p>\n<p>console.log(&#39;4&#39;);</p>\n<p>答案：2 4 3 1</p>\n<pre><code>* 微任务执行过程中产生的新的微任务追加到`当前`微任务队列队尾等待本轮事件循环执行\n* await方法返回的是一个Promise对象，因此await方法执行完毕，后续代码都应归入微任务队列\n* Node环境的事件循环与浏览器不完全一致\n</code></pre>'},function(n,e,t){n.exports=t.p+"images/event-loop.png?144645b50fccbfa42ef607a1f02315e9"},function(n,e,t){n.exports=t.p+"images/macrotask&microtask.png?854e9333d3ed4335941f350752774b53"},function(n,e,t){n.exports='<h3 id="webpack-打包原理">webpack 打包原理</h3>\n<ol>\n<li>读取文件分析模块依赖</li>\n<li>对模块进行解析执行（深度遍历）</li>\n<li>针对不同的模块使用相应的loader</li>\n<li>编译模块，生成抽象语法树（AST）</li>\n<li>循环遍历AST树，拼接js</li>\n</ol>\n<h3 id="loader-原理">loader 原理</h3>\n<blockquote>\n<p>loader 本质是一个函数，输入参数是一个字符串，输出参数也是一个字符串。当然，输出的参数会被当成js代码，从而被 esprima 解析成 AST，触发进一步的依赖解析。</p>\n</blockquote>\n<blockquote>\n<p>webpack 会从右到左的顺序执行loader </p>\n</blockquote>\n<h3 id="webpack-热更新原理">webpack 热更新原理</h3>\n<p><img src="'+t(50)+'" alt="alt webpack热更新"></p>\n<p>Server端使用webpack-dev-server去启动本地服务，内部实现主要使用了webpack、express、websocket。</p>\n<ul>\n<li><p>使用express启动本地服务，当浏览器访问资源时对此做响应。</p>\n</li>\n<li><p>服务端和客户端使用websocket实现长连接</p>\n</li>\n<li><p>webpack监听源文件的变化，即当开发者保存文件时触发webpack的重新编译。</p>\n<ul>\n<li>每次编译都会生成hash值、已改动模块的json文件、已改动模块代码的js文件</li>\n<li>编译完成后通过socket向客户端推送当前编译的hash戳</li>\n</ul>\n</li>\n<li><p>客户端的websocket监听到有文件改动推送过来的hash戳，会和上一次对比</p>\n<ul>\n<li>一致则走缓存</li>\n<li>不一致则通过ajax和jsonp向服务端获取最新资源</li>\n</ul>\n</li>\n<li><p>使用内存文件系统去替换有修改的内容实现局部刷新</p>\n</li>\n</ul>\n'},function(n,e,t){n.exports=t.p+"images/webpack-hot-update.jpeg?2dd1c0bff436166ce9bbedccd950d757"},function(n,e){n.exports='<h3 id="tcp-和-udp">TCP 和 UDP</h3>\n<h4 id="tcp和udp的优缺点">TCP和UDP的优缺点</h4>\n<ul>\n<li>TCP<ul>\n<li>缺点：<ul>\n<li>[1] 三次握手四次挥手，传输更多包，浪费一些带宽</li>\n<li>[2] 为了进行可靠通信，双方都要维持在线，通信过程中服务器server可能出现非常大的并发连接，浪费了系统资源，甚至会出现宕机</li>\n<li>[3] 确认重传也会浪费一些带宽，且在不好的网络中，会不断的断开和连接，降低了传输效率</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>UDP<ul>\n<li>优点：<ul>\n<li>[1] 没有握手，起步快延时小</li>\n<li>[2] 不需要维持双方在线，server不用维护巨量并发连接，节省了系统资源</li>\n<li>[3] 没有重传机制，在不影响使用的情况下，能更高效的利用网络带宽</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id="tcp相比udp为什么是可靠的">TCP相比UDP为什么是可靠的</h4>\n<ol>\n<li>确认和重传机制  <blockquote>\n<p>建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础\n传输过程中，如果Checksum校验失败、丢包或延时，发送端重传</p>\n</blockquote>\n</li>\n<li>数据排序  <blockquote>\n<p>TCP有专门的序列号SN字段，可提供数据re-order</p>\n</blockquote>\n</li>\n<li>流量控制<blockquote>\n<p>窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量</p>\n</blockquote>\n</li>\n<li>拥塞控制<blockquote>\n<p>TCP的拥塞控制由4个核心算法组成。<br>   “慢启动”（Slow Start）\n   “拥塞避免”（Congestion avoidance）\n   “快速重传 ”（Fast Retransmit）\n   “快速恢复”（Fast Recovery）</p>\n</blockquote>\n</li>\n</ol>\n'},function(n,e){n.exports='<h3 id="svelte">Svelte</h3>\n<p><a href="https://svelte.dev/">who am i</a></p>\n'},function(n,e){n.exports='<h3 id="mobx--redux">mobx &amp; redux</h3>\n<blockquote>\n<p>传统React使用的数据管理库为Redux。Redux要解决的问题是统一数据流，数据流完全可控并可追踪。要实现该目标，便需要进行相关的约束。Redux由此引出了dispatch action reducer等概念，对state的概念进行强约束。然而对于一些项目来说，太过强，便失去了灵活性。Mobx便是来填补此空缺的。</p>\n</blockquote>\n<p>Mobx的核心原理是通过action触发state的变化，进而触发state的衍生对象（computed value &amp; Reactions）</p>\n<p>在redux中，唯一可以更改state的途径便是dispatch一个action。这种约束性带来的一个好处是可维护性。整个state只要改变必定是通过action触发的，对此只要找到reducer中对应的action便能找到影响数据改变的原因。</p>\n<h4 id="mobx原理分析">Mobx原理分析</h4>\n<p>Mobx的核心就是通过observable观察某一个变量，当该变量产生变化时，对应的autorun内的回调函数就会发生变化。Mobx是通过代理变量的getter和setter来实现的变量更新功能。首先先代理变量的getter函数，然后通过预执行一遍autorun中回调，从而触发getter函数，来实现观察值的收集，依次来代理setter。之后只要setter触发便执行收集好的回调就ok了。</p>\n<h4 id="redux">Redux</h4>\n<p>Redux是将整个应用状态存储到一个地方上称为store,里面保存着一个状态树store tree,组件可以派发(dispatch)行为(action)给store,而不是直接通知其他组件，组件内部通过订阅store中的状态state来刷新自己的视图。</p>\n'},function(n,e){n.exports='<h3 id="koa--redux-中间件">Koa &amp; Redux 中间件</h3>\n<p>koa 是 洋葱模型 \napp.use 触发一遍 执行时 反向触发一遍</p>\n<p>redux 是 半洋葱模型</p>\n'},function(n,e){n.exports='<h3 id="十进制转换其他进制">十进制转换其他进制</h3>\n<pre><code>const num = 100\nconsole.log(num.toString(2))\nconsole.log(num.toString(8))\nconsole.log(num.toString(16))\nconsole.log(num.toString(32))\nconsole.log(num.toString(64))\n\n//其他转十进制  \nconst x=&#39;110&#39;  \nconsole.log(parseInt(x, 2))  \nconsole.log(parseInt(x, 8))  \nconsole.log(parseInt(x, 16))  \n\n//其他转其他  \n//先用parseInt转成十进制再用toString转到目标进制  \nconsole.log(String.fromCharCode(parseInt(141, 8)))  \nconsole.log(parseInt(&#39;ff&#39;, 16).toString(2))</code></pre>'},function(n,e,t){n.exports='<h3 id="微信小程序原理">微信小程序原理</h3>\n<h4 id="渲染层和逻辑层">渲染层和逻辑层</h4>\n<blockquote>\n<p>由于渲染和逻辑不再同一个浏览器执行，一个在纯JS环境中，一个通过WebView渲染，因此小程序的运行环境分成渲染层和逻辑层，WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。</p>\n</blockquote>\n<p>小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型如图所示</p>\n<p><img src="'+t(57)+'" alt="alt 小程序渲染逻辑"></p>\n<h4 id="数据驱动视图变化">数据驱动视图变化</h4>\n<p>小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。</p>\n<p>通过setData把msg数据从“Hello World”变成“Goodbye”，产生的JS对象对应的节点就会发生变化，此时可以对比前后两个JS对象得到变化的部分，然后把这个差异应用到原来的Dom树上，从而达到更新UI的目的，这就是“数据驱动”的原理。</p>\n<p><img src="'+t(58)+'" alt="alt 小程序数据修改">\n<img src="'+t(59)+'" alt="alt 数据驱动变化原理"></p>\n<h4 id="事件的处理">事件的处理</h4>\n<p>UI界面的程序需要和用户互动，例如用户可能会点击你界面上某个按钮，又或者长按某个区域，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户。由于WebView现在具备的功能只是进行渲染，因此对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给JavaScript进行处理。（和React的事件对象原理类似）</p>\n<p><img src="'+t(60)+'" alt="alt 小程序事件"></p>\n'},function(n,e,t){n.exports=t.p+"images/wechat-mini-app-frame.png?a6f99a100699873ae5768c262e3b3a6a"},function(n,e,t){n.exports=t.p+"images/wechat-mini-app-data-change.png?c6c1aa1cb6e7c8ecee687b0b9b86810e"},function(n,e,t){n.exports=t.p+"images/wechat-mini-app-v-dom-diff.png?d039718d9210941d6530a2d4716b3291"},function(n,e,t){n.exports=t.p+"images/wechat-mini-app-action.png?c2b9c249aa8143f1a69a60db405ff286"},function(n,e){n.exports='<h3 id="使用vw进行移动端自适应布局">使用vw进行移动端自适应布局</h3>\n<p>vw和vh是视口（viewport units）单位，何谓视口，就是根据你浏览器窗口的大小的单位，不受显示器分辨率的影响，是不是很神奇，这就代表了，我们不需要顾虑到现在那么多不同电脑有关分辨率的自适应问题。</p>\n<p>vw是可视窗口的宽度单位，和百分比有点一样，1vw = 可视窗口的宽度的百分之一。比如窗口宽度大小是1800px，那么1vw = 18px。和百分比不一样的是，vw始终相对于可视窗口的宽度，而百分比和其父元素的宽度有关</p>\n<pre><code>// 以750宽度的视觉稿；这样的话开发中的写法就可以直接拿视觉稿上的值 直接 / 100，方便开发\nbody {\n  font-size: calc(100vw / 7.5);\n}</code></pre>'},function(n,e){n.exports='<h3 id="historylisten">history.listen()</h3>\n<p>使用场景 后台系统 侧边栏 根据路由切换选中对应 router</p>\n'},function(n,e){n.exports='<h3 id="mac-chorme-跨域">mac chorme 跨域</h3>\n<p>open -n /Applications/Google\\ Chrome.app/ --args --disable-web-security  --user-data-dir=/Users/YourUserName/Documents/MyChromeDevUserData </p>\n'},function(n,e){n.exports='<h3 id="小程序开发遇到的深坑">小程序开发遇到的深坑</h3>\n<h4 id="bindinput-开发者工具-取不到值">bindinput 开发者工具 取不到值</h4>\n<p>基础库 2.9.2 版本 以上 \n客户端 1.02.1907300 </p>\n<p>反思：应该第一时间寻求社区帮助！！！</p>\n<h4 id="setdata优美写法">setData优美写法</h4>\n<pre><code>// 数组 使用 [] 传 索引\nthis.setData({\n  [`activeData[${index}]`]: res,\n})\n\n// 对象 使用 x.x.x \nthis.setData({\n  [`activeData.${key}`]: res,\n})</code></pre>'},function(n,e){n.exports='<h3 id="数据更新和管理tips">数据更新和管理tips</h3>\n<h4 id="大量数组遍历">大量数组遍历</h4>\n<blockquote>\n<p>将数组转换成Map，生成对应的一个 索引 数组，后续操作对索引数组进行操作。根据返回的索引到Map中取数据</p>\n</blockquote>\n'},function(n,e){n.exports='<h2 id="贴一段hooks的antd列表页">贴一段hooks的antd列表页</h2>\n<blockquote>\n<p>缺点没注释</p>\n</blockquote>\n<pre><code>import React, {useState, useEffect} from &#39;react&#39;\nimport {useParams} from &#39;react-router-dom&#39;\nimport {Table, Input, Button, message} from &#39;antd&#39;\nimport io from &#39;./io&#39;\n\nconst SignUser = () =&gt; {\n  const {activityId} = useParams()\n  const [phone, setPhone] = useState()\n  const [userName, setUserName] = useState()\n  const [list, setList] = useState([])\n  const [currentPage, setCurrentPage] = useState(1)\n  const [total, setTotal] = useState(0)\n  const [pageSize, setPageSize] = useState(10)\n  const [query, setQuery] = useState(false)\n\n  const [fromSearch, setFromSearch] = useState(false)\n\n  useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n      try {\n        const res = await io.getUserList({\n          activityId,\n          phone,\n          userName,\n          currentPage,\n          pageSize,\n        })\n\n        if (fromSearch) {\n          setCurrentPage(1)\n          setFromSearch(false)\n        }\n\n        setTotal(res.count)\n        setList([...(res.data || [])])\n      } catch (e) {\n        message.error(e.message)\n      }\n    }\n\n    fetchData()\n  }, [query])\n\n  useEffect(() =&gt; {\n    setCurrentPage(1)\n  }, [pageSize])\n\n  const renderColumn = number =&gt; {\n    const width = `${(100 / number).toFixed(1)}%`\n\n    return [{\n      title: &#39;用户名&#39;,\n      dataIndex: &#39;userName&#39;,\n      width,\n    }, {\n      title: &#39;性别&#39;,\n      dataIndex: &#39;gender&#39;,\n      width,\n      render: value =&gt; value === 1 ? &#39;男士&#39; : &#39;女士&#39;,\n    }, {\n      title: &#39;手机&#39;,\n      dataIndex: &#39;phone&#39;,\n      width,\n    }, {\n      title: &#39;创建时间&#39;,\n      dataIndex: &#39;ctime&#39;,\n      width,\n    }]\n  }\n\n  return &lt;&gt;\n    &lt;div className=&quot;p24 bgf&quot;&gt;\n      &lt;div className=&quot;FBH FBJB&quot;&gt;\n        &lt;h2&gt;签到用户列表&lt;/h2&gt;\n\n        &lt;div className=&quot;FB1 FBH FBJE&quot;&gt;\n          &lt;Input className=&quot;mr8&quot; style={{width: 200, marginRight: 8}} placeholder=&quot;输入手机号&quot; onChange={e =&gt; setPhone(e.target.value)} /&gt;\n          &lt;Input className=&quot;mr8&quot; style={{width: 200, marginRight: 8}} placeholder=&quot;输入用户名&quot; onChange={e =&gt; setUserName(e.target.value)} /&gt;\n          &lt;Button \n            type=&quot;primary&quot; \n            onClick={() =&gt; {\n              setQuery(!query)\n              setFromSearch(true)\n            }}\n          &gt;搜索&lt;/Button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      &lt;Table \n         columns={renderColumn(8)}\n         dataSource={list}\n         onChange={(pagination, filters, sorter) =&gt; {\n           const {\n             pageSize,\n             current,\n             total,\n           } = pagination\n\n           setCurrentPage(current)\n           setPageSize(pageSize)\n           setTotal(total)\n\n           setQuery(!query)\n         }}\n         pagination={{\n           current: currentPage,\n           pageSize,\n           total,\n           showTotal: sum =&gt; `共${sum}条`,\n           showQuickJumper: true,\n           showSizeChanger: true,\n         }}\n      /&gt;\n    &lt;/div&gt;\n  &lt;/&gt;\n}\n\nexport default SignUser\n</code></pre>'},function(n,e){n.exports='<h3 id="reqiurecontext">reqiure.context</h3>\n<pre><code>const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)\nconst req = require.context(&#39;.&#39;, false, /\\.svg$/)\nrequireAll(req)</code></pre>'},function(n,e){n.exports='<h3 id="坑了2小时-勿忘common">坑了2小时 勿忘common</h3>\n<pre><code>function multiHtmlPlugin(entries) {\n  const pageNames = Object.keys(entries)\n  pageNames.map(name =&gt; {\n    plugins.push(\n      new HtmlWebpackPlugin({\n        filename: `${name}.html`,\n        template: &#39;./index.html&#39;,\n        chunks: [name, &#39;common&#39;],\n        minify: isProd\n          ? {\n            removeComments: true,\n            collapseWhitespace: true,\n            minifyCSS: true,\n          }\n          : true,\n      })\n    )\n  })\n}</code></pre>'},function(n,e){n.exports='<h3 id="设计思路-去中心化">设计思路-去中心化</h3>\n<ul>\n<li>逻辑向内聚合</li>\n<li>去耦合</li>\n<li>render层无逻辑</li>\n</ul>\n'},function(n,e){n.exports='<h3 id="利用requirecontext批量引入图片资源输出成组件">利用require.context批量引入图片资源输出成组件</h3>\n<h4 id="目录结构">目录结构</h4>\n<pre><code>├── folder --------------------  一个目录\n    ├── index.js  -------------  页面入口文件\n    ├── icons  ----------------  图片资源目录</code></pre><h4 id="indexjs">index.js</h4>\n<pre><code>// how to 新增一个icon \n// 将 png 图片复制到 icons目录即可\n// icon 文件名 命名 单一单词 或 驼峰写法 \n\n// 定义 组件对象\nconst mods = {}\n// 获取icons目录下所有png图片\nconst files = require.context(&#39;./icons&#39;, false, /\\.png$/)\n// 获取所有文件 相对路径 \n// eg: [&#39;./zip.png&#39;]\nconst reqPath = files.keys()\n\n// 循环目录结构 组件赋值\nreqPath.forEach(v =&gt; {\n  // 获取 文件名 根据后续需求修改即可\n  const name = v.replace(&#39;./&#39;, &#39;&#39;).split(&#39;.&#39;)[0]\n  // 组件名为 首字母大写的原文件名\n  const modName = name.replace(name[0], name[0].toUpperCase())\n  // 获取图片 \n  // 前面的是直接取文件 后面的是引入组件的写法\n  const img = files(v) || files(v).default \n\n  mods[modName] = ({ style }) =&gt; (\n    &lt;div style={{ width: 24, height: 24, ...(style || {}) }}&gt;\n      &lt;img style={{ width: &#39;100%&#39;, height: &#39;100%&#39; }} src={files(v)} /&gt;\n    &lt;/div&gt;\n  )\n})\n\nconsole.log(mods)\n\nmodule.exports = mods\n</code></pre><h4 id="已知问题-就是全部-png-都打进来了-包可能有点大">已知问题 就是全部 png 都打进来了 包可能有点大</h4>\n'},function(n,e){n.exports='<h3 id="利用suspense和lazy模块懒加载">利用Suspense和lazy模块懒加载</h3>\n<pre><code>import { Suspense, lazy } from &#39;react&#39;\n\nconst Home = lazy(() =&gt; import(&#39;@modules/file/home&#39;))\n\nconst Main = () =&gt; (\n  &lt;Suspense fallback=&#39;&#39;&gt;\n    &lt;Home /&gt;\n  &lt;/Suspense&gt;\n)\n\nexport default Main</code></pre>'},function(n,e){n.exports="<pre><code>import ReactDOM from &#39;react-dom&#39;\nimport { Modal, Alert } from &#39;antd&#39;\n\n// 备注：本来想传参对象的，但别人用了，改动的话工作量太大。先这样定义，看以后时机推动修改吧。\nconst errorEater = ({ code, message }, title, afterClose = () =&gt; {}) =&gt; {\n  const errorMap = new Map([\n    [&#39;0&#39;, &#39;default&#39;],\n    [&#39;1&#39;, &#39;info&#39;],\n    [&#39;2&#39;, &#39;warning&#39;],\n    [&#39;3&#39;, &#39;error&#39;]\n  ])\n\n  const errorType =\n    code &amp;&amp; errorMap.get(code[0]) ? errorMap.get(code[0]) : &#39;error&#39;\n\n  const afterCloseCallback = () =&gt; {\n    window.errorEaterStackLock = false\n\n    window.errorEaterMsgStack.shift()\n\n    afterClose({\n      type: errorType,\n      code,\n      message\n    })\n\n    if (window.errorEaterStack &amp;&amp; window.errorEaterStack.length &gt; 0) {\n      window.errorEaterStackLock = true\n      const next = window.errorEaterStack.shift()\n\n      next()\n    }\n  }\n\n  const renderError = () =&gt; {\n    Modal.error({\n      title: title || &#39;请求错误&#39;,\n      content: message || &#39;&#39;,\n      okText: &#39;知道了&#39;,\n      mask: true,\n      onOk: () =&gt; {\n        afterCloseCallback()\n      },\n      onCancel: () =&gt; {\n        afterCloseCallback()\n      }\n    })\n  }\n\n  const renderAlert = () =&gt; {\n    const wrap = document.createElement(&#39;div&#39;)\n\n    document.body.appendChild(wrap)\n\n    const maskStyle = {\n      position: &#39;fixed&#39;,\n      top: 0,\n      right: 0,\n      left: 0,\n      bottom: 0,\n      height: &#39;100%&#39;,\n      zIndex: 9999\n    }\n\n    const alertWrapStyle = {\n      position: &#39;absolute&#39;,\n      top: 50,\n      left: &#39;50%&#39;,\n      maxWidth: &#39;80%&#39;,\n      zIndex: 9999,\n      transform: &#39;translateX(-50%)&#39;,\n      width: 560\n    }\n\n    ReactDOM.render(\n      &lt;div\n        style={{ ...maskStyle }}\n        onClick={() =&gt; {\n          ReactDOM.unmountComponentAtNode(wrap)\n          document.body.removeChild(wrap)\n          afterCloseCallback()\n        }}\n      &gt;\n        &lt;div style={{ ...alertWrapStyle }}&gt;\n          &lt;Alert\n            message={message}\n            type={errorType}\n            afterClose={() =&gt; {\n              ReactDOM.unmountComponentAtNode(wrap)\n              document.body.removeChild(wrap)\n              afterCloseCallback()\n            }}\n            style={{\n              paddingRight: 50,\n              wordBreak: &#39;break-all&#39;,\n              textAlign: &#39;justify&#39;\n            }}\n            showIcon\n            closable\n          /&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;,\n      wrap\n    )\n  }\n\n  const judgeAction = action =&gt; {\n    if (window.errorEaterStack &amp;&amp; window.errorEaterStack.length &gt; 0) {\n      window.errorEaterStack.push(action)\n      window.errorEaterMsgStack.push(message)\n    } else if (window.errorEaterStackLock) {\n      window.errorEaterStack.push(action)\n      window.errorEaterMsgStack.push(message)\n    } else {\n      window.errorEaterStackLock = true\n      window.errorEaterStack = []\n      window.errorEaterMsgStack = [message]\n      action()\n    }\n  }\n\n  if (errorType === &#39;default&#39;) return null\n\n  if (errorType === &#39;error&#39;) {\n    if (\n      window.errorEaterMsgStack &amp;&amp;\n      window.errorEaterMsgStack.length &gt; 0 &amp;&amp;\n      window.errorEaterMsgStack.some(v =&gt; v === message)\n    )\n      return null\n\n    judgeAction(renderError)\n  }\n\n  if (errorType === &#39;info&#39; || errorType === &#39;warning&#39;) {\n    judgeAction(renderAlert)\n  }\n}\n\nexport default errorEater\n</code></pre>"},function(n,e){n.exports='<h3 id="接口定义返回结果原则">接口定义返回结果原则</h3>\n<ul>\n<li>所见及所得 尽量直接返回 展示的结果</li>\n<li>逻辑洁耦</li>\n</ul>\n'},function(n,e){n.exports='<h3 id="node-简易-本地静态服务">node 简易 本地静态服务</h3>\n<pre><code>const http = require(&#39;http&#39;)\nconst url = require(&#39;url&#39;)\nconst fs = require(&#39;fs&#39;)\nconst path = require(&#39;path&#39;)\n\nconst item = (name, parentPath) =&gt; {\n  const path = parentPath = `${parentPath}/${name}`.slice(1)\n    return `&lt;div&gt;&lt;a href=&quot;${path}&quot;&gt;${name}&lt;/a&gt;&lt;/div&gt;`\n}\n\nconst list = (arr, parentPath) =&gt; {\n  return arr.map(name =&gt; item(name, parentPath)).join(&#39;&#39;)\n} \n\nconst server = http.createServer((req, res) =&gt; {\n  let _path = url.parse(req.url).pathname//去掉search\n    let parentPath = _path\n    _path = path.join(__dirname, _path)\n    try {\n    // 拿到路径所对应的文件描述对象\n    const stats = fs.statSync(_path)\n        if (stats.isFile()) {\n      // 是文件，返回文件内容\n      const file = fs.readFileSync(_path)\n            res.end(file)\n        } else if (stats.isDirectory()) {\n      // 是目录，返回目录列表，让用户可以继续点击\n      const dirArray = fs.readdirSync(_path)\n            res.end(list(dirArray, parentPath))\n        } else {\n      res.end()\n        }\n  } catch (err) {\n    res.writeHead(404, &#39;Not Found&#39;)\n        res.end()\n    }\n})\n\nconst port = 9000\nconst hostname = &#39;127.0.0.1&#39;;\nserver.listen(port, hostname, () =&gt; {\n  console.log(`server is running on http://${hostname}:${port}`)\n})\n</code></pre>'},function(n,e){n.exports='<h3 id="antd-script-标签引入-定制样式">antd script 标签引入 定制样式</h3>\n<blockquote>\n<p>定制样式 需要 less 配合 theme.json ,antd 在 devDependencies 中维护</p>\n</blockquote>\n<h4 id="入口页引入-less">入口页引入 less</h4>\n<pre><code>import &#39;antd/dist/less&#39;</code></pre><h4 id="webpackconfigjs-引入主题配置文件-配置loader">webpack.config.js 引入主题配置文件 配置loader</h4>\n<pre><code>const theme = require(&#39;./theme.json&#39;)\n\n...\n\nmodule: {\n  ...\n  rules: [\n    ...\n    {\n      test: /\\.(le|c)ss$/,\n      use: [\n        isDEV ? &#39;style-loader&#39; : MiniCssExtractPlugin.loader,\n        &#39;css-loader&#39;, \n        { \n          loader: &#39;postcss-loader&#39;,\n          options: {\n            plugins: loader =&gt; [\n              require(&#39;autoprefixer&#39;)(), // CSS浏览器兼容 需要package.json 添加 对应的 browserslist,也有其他方式，自行搜索\n            ]\n          }\n        },\n        `less-loader?{&quot;sourceMap&quot;:true, &quot;modifyVars&quot;:${JSON.stringify(theme)}, &quot;javascriptEnabled&quot;: true}`,\n      ], // 注意排列顺序，执行顺序与排列顺序相反\n    },\n    ...\n  ],\n  ...\n}\n...</code></pre>'},function(n,e){n.exports='<h3 id="objectdefinepropertyobject-propertyname-descriptor">Object.defineProperty(object, propertyname, descriptor)</h3>\n<p>object 必需。 要在其上添加或修改属性的对象。 这可能是一个本机 JavaScript对象（即用户定义的对象或内置对象）或 DOM 对象。\npropertyname 必需。 一个包含属性名称的字符串。\ndescriptor 必需。 属性描述符。 它可以针对数据属性或访问器属性。</p>\n<h4 id="descriptor">descriptor</h4>\n<p>【get】一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。\n【set】 一旦目标对象设置该属性，就会调用这个方法。默认为 undefined</p>\n<p>【value】 属性的值，默认为 undefined。\n【writable】 该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n<p>【configurable]】如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。 。</p>\n<p>【enumerable】 是否能在for-in循环中遍历出来或在Object.keys中列举出来。对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n注意 在调用Object.defineProperty()方法时，如果不指定， configurable， enumerable， writable特性的默认值都是false,这跟之前所 说的对于像前面例子中直接在对象上定义的属性，这个特性默认值为为 true。并不冲突，如下代码所示：</p>\n<pre><code>//调用Object.defineProperty()方法时，如果不指定\nvar someOne = { };\nsomeOne.name = &#39;coverguo&#39;;\nconsole.log(Object.getOwnPropertyDescriptor(someOne, &#39;name&#39;));\n//输出 Object {value: &quot;coverguo&quot;, writable: true, enumerable: true, configurable: true}\n\n//直接在对象上定义的属性，这个特性默认值为为 true\nvar otherOne = {};\nObject.defineProperty(otherOne, &quot;name&quot;, {\n    value:&quot;coverguo&quot; \n});  \nconsole.log(Object.getOwnPropertyDescriptor(otherOne, &#39;name&#39;));\n//输出 Object {value: &quot;coverguo&quot;, writable: false, enumerable: false, configurable: false}</code></pre>'},function(n,e){n.exports='<h3 id="react-router-switch存在的意义">react-router switch存在的意义</h3>\n<p>有<Switch>标签，则其中的<Route>在路径相同的情况下，只匹配第一个，这个可以避免重复匹配；\n无<Switch>标签，则其中的<Route>在路径相同的情况下全都会匹配。更严重的是，还会匹配上级路径的；</p>\n'},function(n,e){n.exports='<h3 id="null-和-undefined-的区别">null 和 undefined 的区别</h3>\n<p>null 表示 不存在的对象\nundefined 表示 不存在的值</p>\n'},function(n,e){n.exports='<h3 id="写一套serverless">写一套serverless</h3>\n'},function(n,e,t){n.exports='<p>如果数据赋值这一动作委托给某函数处理，我们可以借助 AOP 编程思想，在该函数的执行过程中，添加一些附加操作，如上报变更信息、启用回调函数、或者触发指定事件等。正因为如此，Vue 才得以通过 Object.defineProperty 实现双向数据绑定；React 才得以通过 setState 实现组件重绘。mobx 融合了两种处理手法。首先，mobx 基于原始数据构建 observable 实例，在 observable 实例方法变更数据的过程中，将执行 interceptor, listener, reportChanged 等附加操作，这一机制如同 React 内建的 setState 方法在变更组件状态的同时，还能驱动组件重绘。其次，mobx 通过 Object.defineProperty 将原始数据（对象形式）的赋值、取值动作委托给 observable 实例方法去处理，使得原始数据的赋值动作转变成响应式的、取值动作又能获得原始数据内容，这一过程同 Vue 那样使用了 Object.defineProperty 方法。</p>\n<h3 id="vue">Vue</h3>\n<p><img src="'+t(81)+'" alt="alt Vue 数据劫持"></p>\n<p>vue 是利用的是 Object.defineProperty() 对Object的getter和setter方法修改来对数据进行劫持。 并在数据传递变更的时候封装了一层中转站，即我们看到的 Dep 和 Watcher 两个类</p>\n<h3 id="mobx">Mobx</h3>\n<p>mobx 基于原始数据构建 observable 实例。</p>\n<p>mobx 能将如下几种数据类型转变为 observable 实例：ObservableValue 实例作为代理，能将基本数据类型的赋值动作转变成响应式的；ObservableObjectAdministration 实例能处理对象；ObservableArrayAdministration 实例能处理数组；ObservableMap 实例能处理 map 数据结构。</p>\n<p><img src="'+t(82)+'" alt="alt mobx-对象包装"></p>\n'},function(n,e,t){n.exports=t.p+"images/vue-data-catch.png?e681c24702efc742404ac94f5f57a1a5"},function(n,e,t){n.exports=t.p+"images/mobx-object-wrap.jpg?12a029728db3202a6ba12b0a75635400"},function(n,e){n.exports='<h3 id="getsearchparam">getSearchParam</h3>\n<pre><code>export const getSearchParam = search =&gt; search\n  .replace(&#39;?&#39;, &#39;&#39;)\n  .split(&#39;&amp;&#39;)\n  .reduce((pre, v) =&gt; {\n    const arr = v.split(&#39;=&#39;)\n    // 处理中文\n    pre[arr[0]] = decodeURI(arr[1])\n\n    return pre\n  }, {})</code></pre>'},function(n,e){n.exports="<p>给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。</p>\n<p>你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;= 1），这样一轮之后你将得到 k*k 个积分。</p>\n<p>当你将所有盒子都去掉之后，求你能获得的最大积分和。\n示例 1：\n输入:\n[1, 3, 2, 2, 2, 3, 4, 3, 1]\n输出:\n23\n解释:\n[1, 3, 2, 2, 2, 3, 4, 3, 1]\n----&gt; [1, 3, 3, 4, 3, 1] (3<em>3=9 分)\n----&gt; [1, 3, 3, 3, 1] (1</em>1=1 分)\n----&gt; [1, 1] (3<em>3=9 分)\n----&gt; [] (2</em>2=4 分)\n提示：盒子的总数 n 不会超过 100。</p>\n<pre><code>// reduce 处理 数组 每一项，将 一个数据 拆分为 n 个 段\n// 每一段 存储 value length index\n// 拆分时 分为两个数组 \n// 一个数组 按索引 存储 \n// 一个数据 按长度 存储\n\n// 第一轮 要判断所有 长度不为一 并且 左右邻居相等 的 项 并清除\n// 第二轮 要判断所有 长度不为一 并且 左右邻居不相等 的 项 并清除\n\nconst source = [1, 3, 2, 2, 2, 3, 4, 3, 1]\n\nconst formated = source.reduce((pre, value, index, array) =&gt; {\n    // 第一轮第一个\n    if (index === 0) {\n        pre.push({\n            value: value,\n            length: 1,\n            index: pre.length,\n        })\n    } else {\n        // 后面 的 和上一个相等\n        if (value === array[index - 1]) {\n            pre[0].length = pre[0].length + 1\n        } else {\n            pre.push({\n                value,\n                length: 1,\n                index: pre.length,\n            })\n        }\n    }\n\n    return pre\n}, [])\n\nconst sortByLengthArray = formated.sort((a, b) =&gt; {return a.length - b.length})\n\n\nconst getMaxPoint = () =&gt; {\n     const \n}\n</code></pre>"},function(n,e){n.exports='<h3 id="前端缓存策略">前端缓存策略</h3>\n<p>缓存的类型</p>\n<p>浏览器有如下常见的几个字段：</p>\n<p>expires: 设置缓存过期的时间\nprivate: 客户端可以缓存\npublic: 客户端和代理服务器都可缓存\nmax-age=xxx: 缓存的内容将在 xxx 秒后失效\nno-cache: 需要使用对比缓存来验证缓存数据\nno-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发\nlast-modified: 内容上次被修改的时间\nEtag: 文件的特殊标识</p>\n<blockquote>\n<p>缓存方法可以分为强制缓存与协商缓存。</p>\n</blockquote>\n<h4 id="强制缓存">强制缓存</h4>\n<blockquote>\n<p>从字面理解，强制缓存的方式简单粗暴，给<code>cache</code>设置了<code>过期时间</code>，超过这个时间之后cache过期需要重新请求。上述字段中的<code>expires</code>与<code>cache-control中的max-age</code>都属于强制缓存</p>\n</blockquote>\n<blockquote>\n<p>强制缓存优先级高于协商缓存</p>\n</blockquote>\n<h5 id="expires">expires</h5>\n<blockquote>\n<p>expires给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求。</p>\n</blockquote>\n<p><code>Expires: Fri, 04 Jan 2019 12:00:00 GMT</code></p>\n<p>这个方法简单直接，直接设定一个绝对的时间 (当前时间+缓存时间)。但是也存在隐患，例如浏览器当前时间是可以进行更改的，更改之后expires设置的绝对时间相对不准确，cache可能会出现长久不过期或者很快就过期的情况。</p>\n<h5 id="cache-control-max-age">cache-control: max-age</h5>\n<blockquote>\n<p>为了解决expires存在的问题，Http1.1版本中提出了cache-control: max-age，该字段与expires的缓存思路相同，都是设置了一个过期时间，不同的是max-age设置的是相对缓存时间开始往后多久，因此不存在受日期不准确情况的影响。</p>\n</blockquote>\n<p>但是强制缓存存在一个问题，该缓存方式优先级高，如果在过期时间内缓存的资源在服务器上更新了，客服端不能及时获取最新的资源。</p>\n<h4 id="协商缓存">协商缓存</h4>\n<p>协商缓存解决了无法及时获取更新资源的问题。以下两组字段，都可以对资源做标识，由服务器做分析，如果未进行更新，那返回304状态码，从缓存中读取资源，否则重新请求资源</p>\n<h5 id="last-modify">last-modify</h5>\n<blockquote>\n<p>last-modify告知了客户端上次修改该资源的时间，</p>\n</blockquote>\n<p><code>Last-Modified: Wed, 02 Jan 2019 03:06:03 GMT</code></p>\n<p>浏览器将这个值记录在<code>if-modify-since</code>中(浏览器自动记录了该字段信息)，下一次请求相同资源时，与服务器返回的<code>last-modify</code>进行比对，如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。</p>\n<p>last-modify以秒为单位进行更新，如果小于该单位高频进行更新的话，不适合采用该方法。</p>\n<h5 id="etag">ETag</h5>\n<blockquote>\n<p>ETag是对资源的特殊标识</p>\n</blockquote>\n<p><code>Etag: W/&quot;e563df87b65299122770e0a84ada084f&quot;</code></p>\n<p>请求该资源成功之后，将返回的ETag存入if-none-match字段中(浏览器自动记录了该字段信息)，同样在请求资源时传递给服务器，服务器查询该编码对应的资源有无更新，无更新返回304状态，更新返回200并重新请求。</p>\n'},function(n,e){n.exports='<h3 id="gitlab-cliymlmd">gitlab-cli.yml.md</h3>\n<pre><code>image: docker:git\nservices:\n  - docker:dind\n\nvariables:\n  DOCKER_DRIVER: overlay\n  PROJECT_NAME: demo\n  VERSION: ${CI_COMMIT_TAG}\n\ncache:\n  paths:\n    - tgz\n\nstages:\n  - build\n  - package\n\nbuild:\n  image: image_url\n  stage: build\n  script: \n    - rm -rf tgz/*\n    - npm install\n    - sh ./deploy.sh ${VERSION}\n    - cd tgz\n    - ls\n  only:\n    - tags\n\nupload:\n  image: example_file_path\n  stage: package\n  cache:\n    paths:\n      - tgz\n  dependencies:\n    - build\n  script:\n    - ls\n    - mc mb dev/frontend/${PROJECT_NAME}/${CI_COMMIT_TAG}/\n    - mc cp tgz/*${VERSION}.tgz dev/frontend/${PROJECT_NAME}/${CI_COMMIT_TAG}/\n    - cd tgz \n    - ls\n\n  only:\n    - tags\n</code></pre>'},function(n,e){n.exports='<h3 id="shell">shell</h3>\n<pre><code>#!/bin/bash\n# 打 开发包\n# eg sh ./deploy.sh\n# 打 提测包\n# eg: sh ./deploy.sh tag_name\n\n# 打包命令\nnpm run build\n# 复制 vendor 到 打包后的目录\ncp -r ./vendors ./dist\n\n# 获取当前时间戳\nnow=`date +%Y%m%d%H%M`\n\n# 判断是否有tag_name\nif [ x$1 != x ]\nthen\n    #...有参数\n    package_name=&quot;demo_v$1.tgz&quot;\nelse\n    #...没有参数\n    package_name=&quot;demo_$now.tgz&quot;\nfi\n\ntar zcvf $package_name ./dist\nmkdir tgz\nmv $package_name ./tgz</code></pre>'},function(n,e){n.exports='<h3 id="钉钉模块的插件化开发思路-或者-小程序的思路">钉钉模块的插件化开发思路 或者 小程序的思路</h3>\n<p>jsBridge 开放 调用底层 的能力。\n首次 初始化入口。\n每次使用后应该会有缓存机制，达到一定大小后自动回收，或设置过期时间。\n点开应用就是 一个js 应用 （| 小程序）</p>\n'},function(n,e){n.exports='<h3 id="一个图片全屏预览组件">一个图片全屏预览组件</h3>\n<pre><code>import { useState } from &#39;react&#39;\nimport { Button } from &#39;antd&#39;\n\nconst FullscreenPreviewImage = ({src}) =&gt; {\n    const [visible, setVisible] = useState(false)\n\n    return (\n        [\n            &lt;Button shape=&quot;circle&quot; icon=&quot;fullscreen&quot; size=&quot;large&quot; onClick={() =&gt; setVisible(true)} /&gt;,\n            visible &amp;&amp; &lt;div \n                style={{\n                    position: &quot;fixed&quot;,\n                    top: 0,\n                    left: 0,\n                    right: 0,\n                    bottom: 0,\n                    overflowY: &#39;auto&#39;,\n                    zIndex: 1000,\n                    backgroundColor: &#39;rgba(0,0,0, .6)&#39;,\n\n                }}\n                className=&quot;box-align&quot;\n                onClick={() =&gt; setVisible(false)}\n            &gt;\n                &lt;img src={src} style={{cursor: &#39;zoom-out&#39;}} /&gt;\n            &lt;/div&gt;\n        ]\n    )\n}\n\nexport default FullscreenPreviewImage\n\n\n// .box-align\n.box-align {\n    display: -webkit-box;\n    -webkit-box-align: center;\n    -webkit-box-pack: center;\n    display: -moz-box;\n    -moz-box-align: center;\n    -moz-box-pack: center;\n    display: -o-box;\n    -o-box-align: center;\n    -o-box-pack: center;\n    display: -ms-box;\n    -ms-box-align: center;\n    -ms-box-pack: center;\n    display: box;\n    box-align: center;\n    box-pack: center;\n}</code></pre>'},function(n,e,t){n.exports='<h3 id="试试一个文本标注的本地场景">试试一个文本标注的本地场景</h3>\n<p><img src="'+t(91)+'" alt="alt 中文"></p>\n<p><a href="https://webpack.js.org/guides/中文">webpack 英文文档 指南栏</a>  </p>\n'},function(n,e,t){n.exports=t.p+"images/event-loop-中文.png?144645b50fccbfa42ef607a1f02315e9"},function(n,e){n.exports='<h3 id="urlcreateobjecturl">URL.createObjectURL()</h3>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL">MDN URL.createObjectURL()</a></p>\n<h4 id="场景">场景</h4>\n<p>前端手动创建文件并触发浏览器下载</p>\n<pre><code>const data = {}\nconst url = window.URL.createObjectURL(new Blob(data));\nconst link = document.createElement(&#39;a&#39;);\nlink.href = url;\nlink.setAttribute(&#39;download&#39;, &#39;file.&#39; + this.format); // or any other extension\ndocument.body.appendChild(link);\nlink.click();\ndocument.body.removeChild(link);</code></pre>'},function(n,e){n.exports="<pre><code>class BasicPlugin{\n  // 在构造函数中获取用户给该插件传入的配置\n  constructor(options){\n  }\n\n  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象\n  apply(compiler){\n    compiler.plugin(&#39;compilation&#39;,function(compilation) {\n    })\n  }\n}\n// 导出 Plugin\nmodule.exports = BasicPlugin;\n</code></pre><p>Webpack启动后，在读取配置的过程中会先执行new BasicPlugin(options)初始化一个BasicPlugin获得其实例。 在初始化compiler对象后，再调用basicPlugin.apply(compiler)给插件实例传入compiler对象。 插件实例在获取到compiler对象后，就可以通过compiler.plugin(事件名称, 回调函数)监听到Webpack广播出来的事件。 并且可以通过compiler对象去操作Webpack。</p>\n"},function(n,e){n.exports='<h3 id="img">img</h3>\n<pre><code> /&lt;img.*?src=&quot;(.*?)&quot;.*?\\/?&gt;/ig</code></pre><h3 id="a">a</h3>\n<pre><code>/&lt;a.*?href=&quot;(.*?)&quot;.*?\\/?&gt;/ig</code></pre><h3 id="场景">场景</h3>\n<pre><code>const str = &#39;&lt;img src=&quot;../markdown-images/vue-data-catch.png&quot; alt=&quot;alt Vue 数据劫持&quot;&gt; &lt;a href=&quot;https://www.baidu.com&quot; /&gt;&#39;\n\n// 上面的2合1\nconst pattern = /&lt;[img|a].*?[src|href]=&quot;(.*?)&quot;.*?\\/?&gt;/ig\n\nconst matchArr = []\nconst captureArr = []\n\nconst result = marked(markdown).replace(pattern, function (match, capture) {\n    // match 为 整个 标签\n    // capture 为 () 内 匹配的值\n    matchArr.push(match)\n    captureArr.push(capture)\n    return decodeURI(match)\n}) \n\nconsole.log(matchArr)\nconsole.log(captureArr)\n// matchArr \n// [&#39;&lt;img src=&quot;../markdown-images/vue-data-catch.png&quot; alt=&quot;alt Vue 数据劫持&quot;&gt;&#39;, &#39;&lt;a href=&quot;https://www.baidu.com&quot;&#39;]\n\n// captureArr\n// [&#39;../markdown-images/vue-data-catch.png&#39;, &#39;https://www.baidu.com&#39;]</code></pre>'},function(n,e){n.exports='<h3 id="npm-包">npm 包</h3>\n<h4 id="发布">发布</h4>\n<p><code>npm publish</code></p>\n<h4 id="设置npm-源">设置npm 源</h4>\n<p><code>npm config set registry https://registry.npmjs.org/</code></p>\n<h4 id="npm-一些-报错">npm 一些 报错</h4>\n<h5 id="未登陆">未登陆</h5>\n<pre><code>npm ERR! code ENEEDAUTH\nnpm ERR! need auth auth required for publishing\nnpm ERR! need auth You need to authorize this machine using `npm adduser`</code></pre><h5 id="非npm源">非npm源</h5>\n<pre><code>npm ERR! publish Failed PUT 403\nnpm ERR! code E403\nnpm ERR! no_perms Private mode enable, only admin can publish this module:...</code></pre><p>改回npm源</p>\n<pre><code>npm config set registry=http://registry.npmjs.org</code></pre><h5 id="名称已被用">名称已被用</h5>\n<pre><code>npm ERR! publish Failed PUT 403\nnpm ERR! code E403\nnpm ERR! You do not have permission to publish &quot;mini-cli&quot;. Are you logged in as the correct user? : XXX</code></pre><h5 id="版本没改">版本没改</h5>\n<pre><code>npm ERR! publish Failed PUT 403\nnpm ERR! code E403\nnpm ERR! You cannot publish over the previously published versions: 0.0.X. : XXX</code></pre><h5 id="未认证邮箱">未认证邮箱</h5>\n<pre><code>npm ERR! publish Failed PUT 403\nnpm ERR! code E403\nnpm ERR! You must verify your email before publishing a new package</code></pre><h5 id="发布私有包报错">发布私有包报错</h5>\n<pre><code>npm ERR! code E402\nnpm ERR! 402 Payment Required - PUT https://registry.npmjs.org/@yunlong.syl%2fmarkdown-loader - You must sign up for private packages</code></pre><blockquote>\n<p>npm publish --access=public</p>\n</blockquote>\n<h4 id="npm-link">npm link</h4>\n<p>本地调试方法</p>\n<pre><code>在B包里：\nnpm link // 相当于npm install B -g\n在A包里：\nnpm link B // 代码无需修改，package.json中引用B的包会自动指向本地B的打包文件\nA包发布测试环境测试</code></pre>'},,,,,,,,,function(n,e,t){"use strict";t.r(e);var o=t(0),r=t(2);t(18);e.default=function(){console.log(Object(r.useParams)());var n=Object(r.useParams)().fileName;return o.createElement("article",{className:"markdown-body mt20 mb20",dangerouslySetInnerHTML:{__html:t(28)("./".concat(n))}})}}])]);